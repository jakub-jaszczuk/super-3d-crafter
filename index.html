<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Symulator Craftingu 3D - Diamond & Fence Update</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            user-select: none;
        }

        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 20px;
            height: 20px;
            background-color: transparent;
            border: 2px solid rgba(255, 255, 255, 0.8);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            z-index: 10;
            pointer-events: none;
        }
        #crosshair::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 4px;
            height: 4px;
            background-color: white;
            transform: translate(-50%, -50%);
        }

        #hud {
            position: absolute;
            bottom: 100px;
            left: 20px;
            color: white;
            font-size: 14px;
            background: rgba(0, 0, 0, 0.5);
            padding: 15px;
            border-radius: 8px;
            pointer-events: none;
            min-width: 200px;
            line-height: 1.6;
        }

        #quick-slots-container {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 20px;
            z-index: 15;
            pointer-events: none;
        }

        .quick-slot {
            width: 80px;
            height: 80px;
            background: rgba(0, 0, 0, 0.6);
            border: 3px solid #888;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 12px;
            text-align: center;
        }
        
        .slot-active {
            border-color: #00FF00;
            background: rgba(0, 50, 0, 0.6);
        }

        .slot-icon {
            font-size: 24px;
            margin-bottom: 5px;
            font-weight: bold;
        }

        #health-container {
            position: absolute;
            bottom: 60px; 
            right: 20px;
            width: 200px;
            height: 30px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 5px;
            overflow: hidden;
            border: 2px solid #fff;
            padding: 2px;
            box-sizing: border-box;
            pointer-events: none;
        }

        #health-bar {
            height: 100%;
            width: 100%; 
            background: linear-gradient(to right, #00FF00, #008000); 
            transition: width 0.1s;
            border-radius: 3px;
        }

        #health-text {
            position: absolute;
            width: 100%;
            height: 100%;
            line-height: 26px; 
            text-align: center;
            color: white;
            font-weight: bold;
            text-shadow: 1px 1px 2px #000;
        }
        
        #hunger-container {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 200px;
            height: 30px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 5px;
            overflow: hidden;
            border: 2px solid #fff;
            padding: 2px;
            box-sizing: border-box;
            pointer-events: none;
        }

        #hunger-bar {
            height: 100%;
            width: 100%; 
            background: linear-gradient(to right, #FFA500, #FF4500); 
            transition: width 0.1s;
            border-radius: 3px;
        }
        
        #hunger-text {
            position: absolute;
            width: 100%;
            height: 100%;
            line-height: 26px; 
            text-align: center;
            color: white;
            font-weight: bold;
            text-shadow: 1px 1px 2px #000;
        }

        #bow-charge {
            position: absolute;
            top: 40%;
            left: 50%;
            transform: translateX(-50%);
            width: 100px;
            height: 10px;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 5px;
            overflow: hidden;
            display: none; 
        }
        #bow-charge-bar {
            height: 100%;
            width: 0%;
            background: linear-gradient(to right, #6CFF5E, #4CAF50);
        }

        #message-area {
            position: absolute;
            top: 60%; 
            left: 50%;
            transform: translateX(-50%);
            color: #ff5555;
            font-size: 20px;
            font-weight: bold;
            text-shadow: 1px 1px 2px black;
            opacity: 0;
            transition: opacity 0.2s;
            pointer-events: none;
            text-align: center;
            width: 80%;
        }
        
        #slow-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            box-shadow: inset 0 0 100px rgba(100, 255, 100, 0.5);
            pointer-events: none;
            display: none;
            z-index: 5;
        }

        .explosion-effect {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 300px; 
            height: 300px;
            background: radial-gradient(circle, rgba(255, 165, 0, 0.9) 0%, rgba(255, 69, 0, 0.8) 50%, rgba(255, 0, 0, 0) 100%);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            opacity: 0;
            transition: opacity 0.1s, transform 0.1s;
            pointer-events: none;
            z-index: 50;
        }

        #blocker {
            position: absolute;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 20;
            color: white;
            text-align: center;
        }

        .game-menu {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(40, 40, 40, 0.95);
            padding: 20px;
            border-radius: 10px;
            border: 2px solid #555;
            color: white;
            z-index: 30;
            width: 500px; 
            max-width: 95vw;
            text-align: center;
            max-height: 80vh;
            overflow-y: auto;
        }

        .craft-btn {
            display: block;
            width: 100%;
            padding: 8px; 
            margin: 5px 0;
            background: #4CAF50;
            border: none;
            color: white;
            cursor: pointer;
            font-size: 14px;
            border-radius: 5px;
        }
        .craft-btn:disabled {
            background: #555;
            cursor: not-allowed;
            opacity: 0.6;
        }
        .craft-btn:hover:not(:disabled) {
            background: #45a049;
        }
        
        .equip-btn {
            background-color: #2196F3;
            color: white;
            border: none;
            padding: 5px 10px;
            margin-left: 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }
        .equip-btn:hover { background-color: #0b7dda; }

        h1, h2 { margin-top: 0; }
        
        .key {
            background: #eee;
            color: #333;
            padding: 2px 6px;
            border-radius: 4px;
            font-weight: bold;
        }

        #inventory-list {
            text-align: left;
            margin-top: 20px;
            line-height: 1.5;
            border-top: 1px solid #555;
            padding-top: 10px;
        }
    </style>
</head>
<body>

    <!-- UI -->
    <div id="crosshair"></div>
    <div id="slow-overlay"></div>
    
    <div id="hud"></div>
    
    <div id="quick-slots-container">
        <div id="slot-plan" class="quick-slot">
            <div class="slot-icon">üè†</div>
            <div id="slot-plan-text">BRAK<br>SCHEMATU</div>
        </div>
        <div id="slot-arrow" class="quick-slot">
            <div class="slot-icon">üèπ</div>
            <div id="slot-arrow-text">BRAK<br>STRZA≈ÅY</div>
        </div>
    </div>
    
    <div id="health-container">
        <div id="health-bar"></div>
        <div id="health-text">≈ªycie: 100%</div>
    </div>
    
    <div id="hunger-container">
        <div id="hunger-bar"></div>
        <div id="hunger-text">G≈Ç√≥d: 100%</div>
    </div>
    
    <div id="bow-charge">
        <div id="bow-charge-bar"></div>
    </div>

    <div id="message-area">Wiadomo≈õƒá</div>
    <div id="explosion-overlay" class="explosion-effect"></div>

    <div id="blocker">
        <h1 id="blocker-title">Symulator Craftingu 3D</h1>
        <p id="blocker-message">Kliknij, aby zagraƒá</p>
        <p><strong>NOWE SLOTY:</strong> Naci≈õnij <span class="key">I</span>, aby przypisaƒá strza≈Çy i plany do kwadrat√≥w na dole!</p>
        <p><strong>DIAMENTY:</strong> Fioletowe bloki w jaskiniach (Wymagany ≈ªelazny Kilof).</p>
        <p>Sterowanie: <span class="key">W</span><span class="key">A</span><span class="key">S</span><span class="key">D</span> - Chodzenie | <span class="key">SPACJA</span> - Skok</p>
        <p><span class="key">LPM</span> - Atak/Wydobycie | <span class="key">PPM</span> - Budowanie ze slotu | <span class="key">H</span> - Sadzenie</p>
    </div>

    <!-- Menu Craftingu (E) -->
    <div id="crafting-menu" class="game-menu">
        <h2>Menu Craftingu</h2>
        <p>Naci≈õnij <span class="key">E</span> lub <span class="key">ESC</span> aby zamknƒÖƒá</p>
        <div style="border-top: 1px solid #555; margin: 10px 0;"></div>
        
        <button id="btn-planks" class="craft-btn">Deski (4) (1 Drewno)</button>
        <button id="btn-house-plans" class="craft-btn" style="background-color: #FFA07A; color: black;">Plany Domu (20 Dr., 20 Kam.)</button>
        <button id="btn-fence-plans" class="craft-btn" style="background-color: #8B4513;">Schemat P≈Çotu (12 Desek)</button>

        <hr>
        
        <button id="btn-wood-pick" class="craft-btn">Drewniany Kilof (3 Drewna)</button>
        <button id="btn-stone-pick" class="craft-btn">Kamienny Kilof (2 Dr., 1 Kam.)</button>
        <button id="btn-iron-pick" class="craft-btn">≈ªelazny Kilof (2 Dr., 1 ≈ªel.)</button>
        <button id="btn-diamond-pick" class="craft-btn" style="background-color: #9370DB;">Diamentowy Kilof (2 Dr., 3 Diam.)</button>
        
        <button id="btn-diamond-axe" class="craft-btn" style="background-color: #9370DB;">Diamentowa Siekiera (2 Dr., 3 Diam.)</button>

        <hr>

        <button id="btn-stone-sword" class="craft-btn">Kamienny Miecz (2 Kam., 1 Dr.)</button>
        <button id="btn-iron-sword" class="craft-btn">≈ªelazny Miecz (2 ≈ªel., 1 Dr.)</button>
        <button id="btn-poison-sword" class="craft-btn" style="background-color: #2E8B57;">Zatruty Miecz (≈ªel. Miecz + 1 Jad)</button>
        <button id="btn-diamond-sword" class="craft-btn" style="background-color: #9370DB;">Diamentowy Miecz (1 Dr., 2 Diam.)</button>

        <hr>
        
        <button id="btn-bow" class="craft-btn">≈Åuk (3 Nici, 3 Drewna)</button>
        <button id="btn-arrows" class="craft-btn">Strza≈Çy (5) (1 Kam., 1 Dr.)</button>
        <button id="btn-explosive-arrows" class="craft-btn">Wybuchowe Strza≈Çy (5) (1 Strz., 1 Siar.)</button>
        <button id="btn-poison-arrow" class="craft-btn" style="background-color: #32CD32; color: black;">TrujƒÖca Strza≈Ça (1 Jad, 1 Wyb. Strz.)</button>

        <hr>

        <button id="btn-armor" class="craft-btn" style="background-color: #5F9EA0;">Zbroja Sk√≥rzana (10 Sk√≥ry)</button>
        <button id="btn-iron-armor" class="craft-btn" style="background-color: #708090;">≈ªelazna Zbroja (10 ≈ªelaza)</button>
    </div>
    
    <!-- Menu Ekwipunku (I) -->
    <div id="inventory-menu" class="game-menu">
        <h2>Ekwipunek</h2>
        <p>Wybierz co chcesz umie≈õciƒá w szybkich slotach:</p>
        <div id="inventory-list"></div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        let camera, scene, renderer;
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
        let canJump = false, isGameOver = false;
        let slowEndTime = 0; 

        let prevTime = performance.now();
        const velocity = new THREE.Vector3();
        const direction = new THREE.Vector3();
        
        const PLAYER_HEIGHT = 10; 
        const BASE_SPEED = 400.0;
        const JUMP_VELOCITY = 250; 
        const VIEW_DISTANCE = 2000; 
        const FOG_END = 500; 
        const BASE_HUNGER_DEPLETION_RATE = 0.5;

        const IRON_ARMOR_PENALTY = 0.75; 
        const WEB_SLOW_FACTOR = 0.3;
        
        const ZOMBIE_ATTACK_DAMAGE = 1; 
        const SKELETON_ATTACK_DAMAGE = 1;
        const STONE_SWORD_DAMAGE = 3; 
        const IRON_SWORD_DAMAGE = 5;  
        const DIAMOND_SWORD_DAMAGE = 10;
        const REGULAR_ARROW_DAMAGE = 5; 
        const EXPLOSIVE_ARROW_DAMAGE = 10; 

        const MAX_COWS = 15; const MAX_MOBS = 10; const MAX_SPIDERS = 5; const MAX_SKELETONS = 5;
        const SKELETON_RANGE = 50; 

        const INITIAL_PLAYER_STATE = {
            wood: 0, stone: 0, iron: 0, sulphur: 0, diamonds: 0,
            meat: 0, leather: 0, string: 0, venom: 0,
            arrows: 0, explosiveArrows: 0, poisonArrows: 0, 
            saplings: 0, housePlans: 0, fencePlans: 0, planks: 0,
            health: 100, hunger: 100,
            hasWoodenPickaxe: false, hasStonePickaxe: false, hasIronPickaxe: false, hasDiamondPickaxe: false,
            hasStoneSword: false, hasIronSword: false, hasPoisonSword: false, hasDiamondSword: false,
            hasDiamondAxe: false, hasBow: false, hasArmor: false, hasIronArmor: false,
            equippedPlan: null, equippedArrow: null
        };

        let player = JSON.parse(JSON.stringify(INITIAL_PLAYER_STATE)); 

        let isCraftingOpen = false;
        let isInventoryOpen = false; 
        const objects = []; 
        const mobs = [];    
        const projectiles = [];
        const gasClouds = []; 
        let safeZones = []; 
        let raycaster;
        
        let isChargingBowQ = false; 
        let bowChargeStartTime = 0;
        const MAX_CHARGE_TIME = 1.5; 
        const ARROW_MAX_RANGE = 200;

        const blocker = document.getElementById('blocker');
        const blockerTitle = document.getElementById('blocker-title');
        const blockerMessage = document.getElementById('blocker-message');
        const craftingMenu = document.getElementById('crafting-menu');
        const inventoryMenu = document.getElementById('inventory-menu');
        const messageArea = document.getElementById('message-area');
        const bowChargeBar = document.getElementById('bow-charge-bar');
        const bowChargeContainer = document.getElementById('bow-charge');
        const slowOverlay = document.getElementById('slow-overlay');
        const slotPlanText = document.getElementById('slot-plan-text');
        const slotArrowText = document.getElementById('slot-arrow-text');
        const slotPlanDiv = document.getElementById('slot-plan');
        const slotArrowDiv = document.getElementById('slot-arrow');
        
        let lastMobSpawnTime = 0, lastCowSpawnTime = 0, lastSulphurSpawnTime = 0, lastSpiderSpawnTime = 0, lastSkeletonSpawnTime = 0;
        
        document.addEventListener('contextmenu', (e) => e.preventDefault());
        
        init();
        animate();
        
        function getRandomDropAmount() { return Math.floor(Math.random() * 3) + 1; }

        function init() {
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, VIEW_DISTANCE);
            camera.position.y = PLAYER_HEIGHT; 

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            scene.fog = new THREE.Fog(0x87CEEB, 0, FOG_END); 

            const light = new THREE.HemisphereLight(0xffffff, 0x444444);
            light.position.set(0, 20, 0);
            scene.add(light);
            
            const dirLight = new THREE.DirectionalLight(0xffffff);
            dirLight.position.set(50, 200, 100);
            dirLight.castShadow = true;
            scene.add(dirLight);

            const floorGeometry = new THREE.PlaneGeometry(2000, 2000, 100, 100);
            floorGeometry.rotateX(-Math.PI / 2);
            const floorMaterial = new THREE.MeshLambertMaterial({ color: 0x228B22 }); 
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            scene.add(floor);
            objects.push(floor); 

            generateTrees(60);
            generateCaves(8);
            generateDiamondOres(5);
            generateStringBlocks(20); 
            generateSulphurBlocks(15); 
            for(let i = 0; i < 5; i++) createCow(Math.random() * 400 - 200, Math.random() * 400 - 200);

            raycaster = new THREE.Raycaster();
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            const euler = new THREE.Euler(0, 0, 0, 'YXZ');
            document.addEventListener('mousemove', function(event) {
                if (document.pointerLockElement === document.body && !isGameOver) {
                    const movementX = event.movementX || 0;
                    const movementY = event.movementY || 0;
                    euler.setFromQuaternion(camera.quaternion);
                    euler.y -= movementX * 0.002;
                    euler.x -= movementY * 0.002;
                    euler.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, euler.x));
                    camera.quaternion.setFromEuler(euler);
                }
            });

            blocker.addEventListener('click', function() {
                if (isGameOver) resetGame();
                document.body.requestPointerLock();
            });

            document.addEventListener('pointerlockchange', function() {
                if (document.pointerLockElement === document.body) {
                    blocker.style.display = 'none';
                    isCraftingOpen = false; isInventoryOpen = false;
                    craftingMenu.style.display = 'none'; inventoryMenu.style.display = 'none';
                } else {
                    if(!isCraftingOpen && !isInventoryOpen) blocker.style.display = 'flex';
                }
            });

            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            document.addEventListener('mousedown', onMouseDown);
            document.addEventListener('mouseup', onMouseUp); 

            const bind = (id, fn) => document.getElementById(id).addEventListener('click', fn);
            bind('btn-planks', craftPlanks);
            bind('btn-house-plans', craftHousePlans);
            bind('btn-fence-plans', craftFencePlans);
            bind('btn-wood-pick', () => craftTool('pick', 'wood'));
            bind('btn-stone-pick', () => craftTool('pick', 'stone'));
            bind('btn-iron-pick', () => craftTool('pick', 'iron'));
            bind('btn-diamond-pick', () => craftTool('pick', 'diamond'));
            bind('btn-diamond-axe', () => craftTool('axe', 'diamond'));
            bind('btn-stone-sword', () => craftTool('sword', 'stone'));
            bind('btn-iron-sword', () => craftTool('sword', 'iron'));
            bind('btn-diamond-sword', () => craftTool('sword', 'diamond'));
            bind('btn-poison-sword', craftPoisonSword);
            bind('btn-bow', craftBow);
            bind('btn-arrows', craftArrows);
            bind('btn-explosive-arrows', craftExplosiveArrows);
            bind('btn-poison-arrow', craftPoisonArrow);
            bind('btn-armor', craftArmor);
            bind('btn-iron-armor', craftIronArmor);

            updateHUD();
            window.addEventListener('resize', onWindowResize);
        }

        function toggleCrafting() {
            if (isGameOver) return; 
            isCraftingOpen = !isCraftingOpen;
            if (isCraftingOpen) {
                if (isInventoryOpen) toggleInventory(); 
                document.exitPointerLock();
                craftingMenu.style.display = 'block';
                updateCraftingButtons();
            } else {
                craftingMenu.style.display = 'none';
                document.body.requestPointerLock();
            }
        }

        function toggleInventory() {
            if (isGameOver) return; 
            isInventoryOpen = !isInventoryOpen;
            if (isInventoryOpen) {
                if (isCraftingOpen) toggleCrafting(); 
                document.exitPointerLock();
                inventoryMenu.style.display = 'block';
                updateInventoryDisplay();
            } else {
                inventoryMenu.style.display = 'none';
                document.body.requestPointerLock();
            }
        }

        function showMessage(text, color) {
            messageArea.innerHTML = text; 
            messageArea.style.color = color; 
            messageArea.style.opacity = 1;
            if(messageArea.timeout) clearTimeout(messageArea.timeout);
            messageArea.timeout = setTimeout(() => messageArea.style.opacity = 0, 1500);
        }

        function eatMeat() { 
            if(player.meat>0 && (player.hunger<100 || player.health<100)) { 
                player.meat--; player.hunger=100; player.health=Math.min(100, player.health+20); 
                updateHUD(); 
                showMessage("Mniam!", "orange"); 
            }
        }

        function resetGame() {
             const keptObjects = [];
            for(let i = 1; i < objects.length; i++) {
                if (objects[i].userData.type === 'death_block') keptObjects.push(objects[i]);
                else {
                    scene.remove(objects[i]);
                    if (objects[i].userData.leaves) scene.remove(objects[i].userData.leaves);
                }
            }
            
            const floor = objects[0];
            objects.length = 0; objects.push(floor);
            keptObjects.forEach(obj => objects.push(obj));

            mobs.forEach(mob => scene.remove(mob)); mobs.length = 0;
            projectiles.forEach(proj => scene.remove(proj)); projectiles.length = 0;
            gasClouds.forEach(c => scene.remove(c.mesh)); gasClouds.length = 0;
            safeZones = [];

            player = JSON.parse(JSON.stringify(INITIAL_PLAYER_STATE));
            
            generateTrees(60); generateCaves(8); generateDiamondOres(5); generateStringBlocks(20); generateSulphurBlocks(15);
            for(let i = 0; i < 5; i++) createCow(Math.random() * 400 - 200, Math.random() * 400 - 200);

            isGameOver = false; slowEndTime = 0; slowOverlay.style.display = 'none';
            blockerTitle.innerText = "Symulator Craftingu 3D";
            blockerMessage.innerHTML = "Kliknij, aby zagraƒá";
            camera.position.set(0, PLAYER_HEIGHT, 0); velocity.set(0, 0, 0);
            updateHUD();
        }
        
        function generateDiamondOres(count) {
            for (let i = 0; i < count; i++) {
                const cx = Math.random() * 300 - 150; 
                const cz = Math.random() * 300 - 150;
                for (let j = 0; j < 3; j++) {
                    const m = new THREE.Mesh(new THREE.BoxGeometry(2.5, 2.5, 2.5), new THREE.MeshLambertMaterial({ color: 0x800080 })); // Purple
                    m.position.set(cx + (Math.random()-0.5)*10, (Math.random()*10)-4, cz + (Math.random()-0.5)*10);
                    m.userData = { type: 'diamond_ore', originalColor: 0x800080 };
                    scene.add(m); objects.push(m);
                }
            }
        }
        
        function generateTrees(count) {
            const scale = 1.5;
            const trunkHeight = PLAYER_HEIGHT * scale;
            const trunkGeom = new THREE.CylinderGeometry(0.8 * scale, 1.0 * scale, trunkHeight, 8);
            const leavesGeom = new THREE.BoxGeometry(5 * scale, 5 * scale, 5 * scale);
            for (let i = 0; i < count; i++) {
                const x = Math.random() * 400 - 200; const z = Math.random() * 400 - 200;
                const trunk = new THREE.Mesh(trunkGeom, new THREE.MeshLambertMaterial({ color: 0x8B4513 }));
                trunk.position.set(x, trunkHeight / 2, z); trunk.userData = { type: 'wood', originalColor: 0x8B4513 };
                scene.add(trunk); objects.push(trunk);
                const leaves = new THREE.Mesh(leavesGeom, new THREE.MeshLambertMaterial({ color: 0x2E8B57 }));
                leaves.position.set(x, trunkHeight + (2.5 * scale) - (1.5 * scale), z); scene.add(leaves);
                trunk.userData.leaves = leaves; 
            }
        }
        function generateCaves(count) {
            for (let i = 0; i < count; i++) {
                const cx = Math.random() * 300 - 150; const cz = Math.random() * 300 - 150;
                for (let j = 0; j < 30; j++) {
                    const isIron = Math.random() < 0.3; 
                    const m = new THREE.Mesh(new THREE.BoxGeometry(2.5, 2.5, 2.5), new THREE.MeshLambertMaterial({ color: isIron ? 0x964B00 : 0x808080 }));
                    m.position.set(cx + (Math.random()-0.5)*20, (Math.random()*11)-4, cz + (Math.random()-0.5)*20);
                    m.userData = { type: isIron ? 'iron_ore' : 'stone', originalColor: isIron ? 0x964B00 : 0x808080 };
                    scene.add(m); objects.push(m);
                }
            }
        }
        function generateStringBlocks(count) {
            for (let i = 0; i < count; i++) {
                const b = new THREE.Mesh(new THREE.BoxGeometry(3.5, 3.5, 3.5), new THREE.MeshLambertMaterial({ color: 0xFFFFFF }));
                b.position.set(Math.random() * 400 - 200, 1.75, Math.random() * 400 - 200);
                b.userData = { type: 'string_block', originalColor: 0xFFFFFF };
                scene.add(b); objects.push(b);
            }
        }
        function generateSulphurBlocks(count) { 
            for (let i = 0; i < count; i++) spawnSulphurBlock(Math.random() * 400 - 200, Math.random() * 400 - 200); 
        }
        function spawnSulphurBlock(x, z) {
            const block = new THREE.Mesh(new THREE.BoxGeometry(4, 4, 4), new THREE.MeshLambertMaterial({ color: 0xFFFF00 }));
            block.position.set(x, 2, z); block.userData = { type: 'sulphur_ore', originalColor: 0xFFFF00 };
            scene.add(block); objects.push(block);
        }
        function createDeathBlock(x, z, loot) {
            const block = new THREE.Mesh(new THREE.BoxGeometry(5, 5, 5), new THREE.MeshLambertMaterial({ color: 0x0000FF }));
            block.position.set(x, 2.5, z); block.userData = { type: 'death_block', loot: loot, originalColor: 0x0000FF };
            scene.add(block); objects.push(block);
        }

        // --- BRAKUJƒÑCE FUNKCJE TWORZENIA MOB√ìW ---
        function createCow(x, z) {
            const g = new THREE.Group();
            const b = new THREE.Mesh(new THREE.BoxGeometry(3, 5, 4.5), new THREE.MeshLambertMaterial({ color: 0x654321 })); b.position.y = 2.5; g.add(b);
            const h1 = new THREE.Mesh(new THREE.BoxGeometry(0.3, 1, 0.3), new THREE.MeshLambertMaterial({ color: 0xFFD700 })); h1.position.set(-1.4, 5, 2.1); g.add(h1);
            const h2 = h1.clone(); h2.position.set(1.4, 5, 2.1); g.add(h2);
            g.position.set(x, 0, z); g.rotation.y = Math.random() * Math.PI * 2;
            g.userData = { type: 'cow', originalColor: 0x654321, health: 1, walkDirection: new THREE.Vector3(Math.random()-0.5,0,Math.random()-0.5).normalize(), walkSpeed: 10, nextTurnTime: performance.now()+2000 };
            scene.add(g); mobs.push(g);
        }

        function createZombie(x, z) {
            const g = new THREE.Group();
            const h = new THREE.Mesh(new THREE.BoxGeometry(2.5, 2.5, 2.5), new THREE.MeshLambertMaterial({ color: 0x006400 })); h.position.y = 7.5;
            const b = new THREE.Mesh(new THREE.BoxGeometry(2.5, 4.5, 1.5), new THREE.MeshLambertMaterial({ color: 0x228B22 })); b.position.y = 4;
            g.add(h); g.add(b); g.position.set(x, 0, z); g.userData = { type: 'zombie', originalColor: 0x228B22, health: 10, walkSpeed: 15, attackRange: 2, attackCooldown: 1000, lastAttackTime: 0 };
            scene.add(g); mobs.push(g);
        }

        function createSpider(x, z) {
            const g = new THREE.Group();
            const b = new THREE.Mesh(new THREE.SphereGeometry(2, 8, 8), new THREE.MeshLambertMaterial({ color: 0x111111 })); b.position.y = 2; g.add(b);
            g.position.set(x, 0, z); g.userData = { type: 'spider', originalColor: 0x111111, health: 2, walkSpeed: 18, lastAttackTime: 0, attackCooldown: 5000 };
            scene.add(g); mobs.push(g);
        }

        function createSkeleton(x, z) {
            const g = new THREE.Group();
            const mat = new THREE.MeshLambertMaterial({ color: 0xDDDDDD });
            const h = new THREE.Mesh(new THREE.BoxGeometry(2, 2, 2), mat); h.position.y = 8;
            const b = new THREE.Mesh(new THREE.BoxGeometry(1.5, 4, 1), mat); b.position.y = 5;
            const bow = new THREE.Mesh(new THREE.BoxGeometry(0.5, 4, 0.5), new THREE.MeshLambertMaterial({ color: 0x5C4033 })); bow.position.set(1.5, 6, 1);
            g.add(h); g.add(b); g.add(bow);
            g.position.set(x, 0, z); g.userData = { type: 'skeleton', originalColor: 0xDDDDDD, health: 20, walkSpeed: 12, attackRange: SKELETON_RANGE, lastAttackTime: 0, attackCooldown: 3000 };
            scene.add(g); mobs.push(g);
        }

        // --- INTERAKCJE ---
        function handleHit(object) {
            if (!object) return;
            const type = object.userData.type;
            
            if (object.material && object.userData.originalColor) {
                object.material.color.setHex(0xffffff); setTimeout(() => object.material.color.setHex(object.userData.originalColor), 100);
            } else if (object.children && object.children[0].material) {
                object.children.forEach(m => { if(m.material) m.material.color.setHex(0xffffff); });
                setTimeout(() => object.children.forEach(m => { if(m.material) m.material.color.setHex(object.userData.originalColor); }), 100);
            }

            if (type === 'wood') {
                let amount = getRandomDropAmount();
                if(player.hasDiamondAxe) amount = 5;
                player.wood += amount;
                if(Math.random() < 0.20) { player.saplings++; showMessage(`+${amount} Drewno, +SADZONKA!`, "lightgreen"); }
                else showMessage(`+${amount} Drewno`, "#4CAF50");
                scene.remove(object); if(object.userData.leaves) scene.remove(object.userData.leaves); objects.splice(objects.indexOf(object), 1);
            }
            else if (type === 'stone') {
                if(player.hasWoodenPickaxe || player.hasStonePickaxe || player.hasIronPickaxe || player.hasDiamondPickaxe) {
                    let amount = player.hasDiamondPickaxe ? 5 : getRandomDropAmount();
                    player.stone += amount; showMessage(`+${amount} Kamie≈Ñ`, "#808080"); scene.remove(object); objects.splice(objects.indexOf(object), 1);
                } else showMessage("Wymagany kilof!", "red");
            }
            else if (type === 'iron_ore') {
                if(player.hasStonePickaxe || player.hasIronPickaxe || player.hasDiamondPickaxe) {
                    let amount = player.hasDiamondPickaxe ? 5 : getRandomDropAmount();
                    player.iron += amount; showMessage(`+${amount} ≈ªelazo`, "#D3D3D3"); scene.remove(object); objects.splice(objects.indexOf(object), 1);
                } else showMessage("Wymagany Kamienny Kilof!", "red");
            }
            else if (type === 'diamond_ore') {
                if(player.hasIronPickaxe || player.hasDiamondPickaxe) {
                    let amount = player.hasDiamondPickaxe ? 5 : getRandomDropAmount();
                    player.diamonds += amount; showMessage(`+${amount} DIAMENTY!`, "#9370DB"); scene.remove(object); objects.splice(objects.indexOf(object), 1);
                } else showMessage("Wymagany ≈ªelazny Kilof!", "red");
            }
            else if (type === 'sulphur_ore') {
                if(player.hasWoodenPickaxe || player.hasStonePickaxe || player.hasIronPickaxe || player.hasDiamondPickaxe) {
                    let amount = player.hasDiamondPickaxe ? 5 : getRandomDropAmount();
                    player.sulphur += amount; showMessage(`+${amount} Siarka`, "#FFFF00"); scene.remove(object); objects.splice(objects.indexOf(object), 1);
                } else showMessage("Wymagany kilof!", "red");
            }
            else if (type === 'string_block') {
                if (player.hasStoneSword || player.hasIronSword || player.hasPoisonSword || player.hasDiamondSword) {
                    let amount = getRandomDropAmount();
                    player.string += amount;
                    showMessage(`+${amount} Niƒá`, "white");
                    scene.remove(object);
                    objects.splice(objects.indexOf(object), 1);
                } else {
                    showMessage("Wymagany miecz!", "red");
                }
            }
            else if (type === 'death_block') {
                const loot = object.userData.loot;
                Object.keys(loot).forEach(k => { if(player.hasOwnProperty(k)) player[k] += (typeof loot[k] === 'number' ? loot[k] : 0); });
                ['hasWoodenPickaxe','hasStonePickaxe','hasIronPickaxe','hasDiamondPickaxe','hasDiamondAxe','hasStoneSword','hasIronSword','hasPoisonSword','hasDiamondSword','hasBow','hasArmor','hasIronArmor'].forEach(k => {
                    if(loot[k]) player[k] = true;
                });
                showMessage("Odzyskano ekwipunek!", "blue");
                scene.remove(object); objects.splice(objects.indexOf(object), 1);
            }
            else if (type === 'cow' || type === 'zombie' || type === 'spider' || type === 'skeleton') {
                let dmg = 1;
                if (player.hasDiamondSword) dmg = DIAMOND_SWORD_DAMAGE;
                else if (player.hasPoisonSword) dmg = IRON_SWORD_DAMAGE;
                else if (player.hasIronSword) dmg = IRON_SWORD_DAMAGE;
                else if (player.hasStoneSword) dmg = STONE_SWORD_DAMAGE;

                if (dmg === 1 && type !== 'cow') { showMessage("U≈ºyj miecza!", "red"); return; }

                object.userData.health -= dmg;
                
                if (player.hasPoisonSword) { 
                    object.userData.slowEndTime = performance.now() + 3000; 
                    showMessage(`Trafienie (Trucizna)! -${dmg} HP`, "lightgreen"); 
                } else { 
                    showMessage(`Trafienie! -${dmg} HP`, "red"); 
                }

                if (object.userData.health <= 0) killMob(object);
            }
            updateHUD();
        }

        function killMob(object) {
            const type = object.userData.type;
            if (type === 'cow') { player.meat++; player.leather++; showMessage("+1 Miƒôso, +1 Sk√≥ra", "#ffcc00"); }
            else if (type === 'zombie') { player.leather += getRandomDropAmount(); showMessage(`Zabito Zombi!`, "lightgreen"); }
            else if (type === 'spider') { 
                if (player.hasDiamondSword) { player.venom += 3; showMessage("Zabito PajƒÖka! +3 Jady (Diamentowy Miecz)", "purple"); }
                else { player.venom++; showMessage(`Zabito PajƒÖka! +1 Jad`, "purple"); }
            }
            else if (type === 'skeleton') { player.arrows += 3; showMessage("Zabito Szkieleta! +3 Strza≈Çy", "white"); }
            scene.remove(object); mobs.splice(mobs.indexOf(object), 1); updateHUD();
        }

        function onKeyDown(event) {
            if (isGameOver) return; 
            switch (event.code) {
                case 'ArrowUp': case 'KeyW': moveForward = true; break;
                case 'ArrowLeft': case 'KeyA': moveLeft = true; break;
                case 'ArrowDown': case 'KeyS': moveBackward = true; break;
                case 'ArrowRight': case 'KeyD': moveRight = true; break;
                case 'Space': if (canJump) { velocity.y += JUMP_VELOCITY; canJump = false; } break;
                case 'KeyE': if (isInventoryOpen) toggleInventory(); toggleCrafting(); break;
                case 'KeyI': if (isCraftingOpen) toggleCrafting(); toggleInventory(); break;
                case 'Escape': if (isCraftingOpen) toggleCrafting(); else if (isInventoryOpen) toggleInventory(); else if (document.pointerLockElement) document.exitPointerLock(); break;
                case 'KeyR': eatMeat(); break;
                case 'KeyH': 
                    if(player.saplings > 0) { 
                        player.saplings--; 
                        const x = camera.position.x; const z = camera.position.z;
                        const trunk = new THREE.Mesh(new THREE.CylinderGeometry(1.2,1.5,15,8), new THREE.MeshLambertMaterial({color:0x8B4513}));
                        trunk.position.set(x,7.5,z); trunk.userData={type:'wood',originalColor:0x8B4513}; scene.add(trunk); objects.push(trunk);
                        const leaves = new THREE.Mesh(new THREE.BoxGeometry(7.5,7.5,7.5), new THREE.MeshLambertMaterial({color:0x2E8B57}));
                        leaves.position.set(x,15,z); scene.add(leaves); trunk.userData.leaves=leaves;
                        updateHUD(); showMessage("Zasadzono!", "lightgreen");
                    } else showMessage("Brak sadzonek!", "red");
                    break;
                case 'KeyQ': 
                    if(player.hasBow && player.equippedArrow) {
                        isChargingBowQ = true; bowChargeStartTime = performance.now(); bowChargeContainer.style.display = 'block';
                    } else if (player.hasBow) showMessage("Wybierz strza≈Çy (I)!", "yellow");
                    break;
            }
        }

        function onKeyUp(event) {
            if (isGameOver) return; 
            switch (event.code) {
                case 'ArrowUp': case 'KeyW': moveForward = false; break;
                case 'ArrowLeft': case 'KeyA': moveLeft = false; break;
                case 'ArrowDown': case 'KeyS': moveBackward = false; break;
                case 'ArrowRight': case 'KeyD': moveRight = false; break;
                case 'KeyQ': if (isChargingBowQ) { fireArrow(); isChargingBowQ = false; bowChargeContainer.style.display = 'none'; } break;
            }
        }

        // --- BRAKUJƒÑCE FUNKCJE (PRZYWR√ìCONE) ---

        function onMouseDown(event) {
            if (isGameOver || document.pointerLockElement !== document.body) return;
            
            if (event.button === 0) { // LPM - Atak/Wydobycie
                raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
                const intersects = raycaster.intersectObjects(objects.concat(mobs), true);
                
                if (intersects.length > 0 && intersects[0].distance < 12) {
                    let target = intersects[0].object;
                    // Znajd≈∫ g≈Ç√≥wny obiekt (grupƒô moba lub blok)
                    while(target.parent && target.parent.type !== 'Scene' && !target.userData.type) {
                        target = target.parent;
                    }
                    if(target.userData.type) handleHit(target);
                    else if (target.parent && target.parent.userData.type) handleHit(target.parent);
                }
            } else if (event.button === 2) { // PPM - Budowanie
                if(player.equippedPlan) {
                    raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
                    const intersects = raycaster.intersectObjects(objects);
                    if (intersects.length > 0 && intersects[0].distance < 20) {
                        const p = intersects[0].point;
                        if(player.equippedPlan === 'house') buildHouse(p.x, p.z);
                        else if(player.equippedPlan === 'fence') buildFence(p.x, p.z);
                    }
                }
            }
        }

        function onMouseUp(event) {}

        function fireArrow() {
            if (!player.hasBow) return;
            let arrowType = player.equippedArrow || 'regular'; 
            if (arrowType === 'regular' && player.arrows > 0) player.arrows--;
            else if (arrowType === 'explosive' && player.explosiveArrows > 0) player.explosiveArrows--;
            else if (arrowType === 'poison' && player.poisonArrows > 0) player.poisonArrows--;
            else return; 
            
            updateHUD();
            const start = camera.position.clone();
            const dir = new THREE.Vector3();
            camera.getWorldDirection(dir);
            const target = start.clone().add(dir.multiplyScalar(100)); 
            shootProjectile(start, target, false, false);
            
            const proj = projectiles[projectiles.length-1];
            proj.userData.isExplosive = (arrowType === 'explosive');
            proj.userData.isPoison = (arrowType === 'poison');
            proj.userData.type = 'player_projectile';
            proj.material.color.setHex(arrowType === 'explosive' ? 0xFF0000 : (arrowType === 'poison' ? 0x00FF00 : 0xAAAAAA));
        }

        function checkSpawns(time) {
            if (time - lastMobSpawnTime > 10000 && mobs.length < MAX_MOBS) {
                if (Math.random() < 0.5) createZombie((Math.random()-0.5)*300, (Math.random()-0.5)*300);
                else createSkeleton((Math.random()-0.5)*300, (Math.random()-0.5)*300);
                lastMobSpawnTime = time;
            }
            if (time - lastCowSpawnTime > 15000 && mobs.filter(m => m.userData.type === 'cow').length < MAX_COWS) {
                 createCow((Math.random()-0.5)*300, (Math.random()-0.5)*300);
                 lastCowSpawnTime = time;
            }
            if (time - lastSulphurSpawnTime > 20000) {
                 spawnSulphurBlock((Math.random()-0.5)*300, (Math.random()-0.5)*300);
                 lastSulphurSpawnTime = time;
            }
        }

        // Funkcje Craftingu i Budowania
        function updateHUD() {
            document.getElementById('health-bar').style.width = player.health + '%';
            document.getElementById('hunger-bar').style.width = player.hunger + '%';
            document.getElementById('health-text').innerText = `≈ªycie: ${Math.ceil(player.health)}%`;
            document.getElementById('hunger-text').innerText = `G≈Ç√≥d: ${Math.ceil(player.hunger)}%`;
            const hud = document.getElementById('hud');
            hud.innerHTML = `
                Drewno: ${player.wood} | Kamie≈Ñ: ${player.stone} | ≈ªelazo: ${player.iron}<br>
                Diamenty: ${player.diamonds} | Siarka: ${player.sulphur} | Nici: ${player.string}<br>
                Deski: ${player.planks} | Sk√≥ra: ${player.leather} | Miƒôso: ${player.meat}<br>
                Strza≈Çy: ${player.arrows} | Wyb.: ${player.explosiveArrows} | Tru.: ${player.poisonArrows}
            `;
            updateCraftingButtons();
        }

        function updateCraftingButtons() {
           const btn = (id, enable) => document.getElementById(id).disabled = !enable;
           btn('btn-planks', player.wood >= 1);
           btn('btn-house-plans', player.wood >= 20 && player.stone >= 20);
           btn('btn-fence-plans', player.planks >= 12);
           btn('btn-wood-pick', player.wood >= 3);
           btn('btn-stone-pick', player.wood >= 2 && player.stone >= 1);
           btn('btn-iron-pick', player.wood >= 2 && player.iron >= 1);
           btn('btn-diamond-pick', player.wood >= 2 && player.diamonds >= 3);
           btn('btn-diamond-axe', player.wood >= 2 && player.diamonds >= 3);
           btn('btn-stone-sword', player.stone >= 2 && player.wood >= 1);
           btn('btn-iron-sword', player.iron >= 2 && player.wood >= 1);
           btn('btn-poison-sword', player.hasIronSword && player.venom >= 1);
           btn('btn-diamond-sword', player.wood >= 1 && player.diamonds >= 2);
           btn('btn-bow', player.string >= 3 && player.wood >= 3);
           btn('btn-arrows', player.stone >= 1 && player.wood >= 1);
           btn('btn-explosive-arrows', player.arrows >= 1 && player.sulphur >= 1);
           btn('btn-poison-arrow', player.explosiveArrows >= 1 && player.venom >= 1);
           btn('btn-armor', player.leather >= 10);
           btn('btn-iron-armor', player.iron >= 10);
        }

        function craftPlanks() { if(player.wood >= 1) { player.wood--; player.planks += 4; updateHUD(); showMessage("+4 Deski", "lime"); } }
        function craftHousePlans() { if(player.wood >= 20 && player.stone >= 20) { player.wood-=20; player.stone-=20; player.housePlans++; updateHUD(); showMessage("+Plan Domu", "gold"); } }
        function craftFencePlans() { if(player.planks >= 12) { player.planks-=12; player.fencePlans++; updateHUD(); showMessage("+Schemat P≈Çotu", "brown"); } }
        
        function craftTool(type, mat) {
            let costWood = 0, costStone = 0, costIron = 0, costDiam = 0;
            if(type==='pick') {
                if(mat==='wood') costWood=3;
                if(mat==='stone') { costWood=2; costStone=1; }
                if(mat==='iron') { costWood=2; costIron=1; }
                if(mat==='diamond') { costWood=2; costDiam=3; }
            } else if(type==='sword') {
                if(mat==='stone') { costWood=1; costStone=2; }
                if(mat==='iron') { costWood=1; costIron=2; }
                if(mat==='diamond') { costWood=1; costDiam=2; }
            } else if(type==='axe') { // diamond axe
                 costWood=2; costDiam=3;
            }

            if(player.wood>=costWood && player.stone>=costStone && player.iron>=costIron && player.diamonds>=costDiam) {
                player.wood-=costWood; player.stone-=costStone; player.iron-=costIron; player.diamonds-=costDiam;
                let key = 'has' + mat.charAt(0).toUpperCase() + mat.slice(1) + (type==='pick'?'Pickaxe':(type==='axe'?'Axe':'Sword'));
                player[key] = true;
                updateHUD(); showMessage(`Stworzono: ${mat} ${type}`, "lime");
            }
        }
        function craftPoisonSword() { if(player.hasIronSword && player.venom>=1) { player.venom--; player.hasPoisonSword=true; updateHUD(); showMessage("Stworzono Zatruty Miecz!", "green"); } }
        function craftBow() { if(player.string>=3 && player.wood>=3) { player.string-=3; player.wood-=3; player.hasBow=true; updateHUD(); showMessage("Stworzono ≈Åuk!", "orange"); } }
        function craftArrows() { if(player.stone>=1 && player.wood>=1) { player.stone--; player.wood--; player.arrows+=5; updateHUD(); showMessage("+5 Strza≈Ç", "white"); } }
        function craftExplosiveArrows() { if(player.arrows>=1 && player.sulphur>=1) { player.arrows--; player.sulphur--; player.explosiveArrows+=5; updateHUD(); showMessage("+5 Wybuchowych Strza≈Ç", "red"); } }
        function craftPoisonArrow() { if(player.explosiveArrows>=1 && player.venom>=1) { player.explosiveArrows--; player.venom--; player.poisonArrows++; updateHUD(); showMessage("+1 TrujƒÖca Strza≈Ça", "green"); } }
        function craftArmor() { if(player.leather>=10) { player.leather-=10; player.hasArmor=true; updateHUD(); showMessage("Stworzono Zbrojƒô!", "blue"); } }
        function craftIronArmor() { if(player.iron>=10) { player.iron-=10; player.hasIronArmor=true; updateHUD(); showMessage("Stworzono ≈ªelaznƒÖ Zbrojƒô!", "gray"); } }

        function buildHouse(x, z) {
            if(player.housePlans > 0) {
                player.housePlans--;
                const h = new THREE.Group();
                const walls = new THREE.Mesh(new THREE.BoxGeometry(20, 15, 20), new THREE.MeshLambertMaterial({color: 0x8B4513}));
                walls.position.y = 7.5; h.add(walls);
                const roof = new THREE.Mesh(new THREE.ConeGeometry(15, 10, 4), new THREE.MeshLambertMaterial({color: 0x800000}));
                roof.position.y = 20; roof.rotation.y = Math.PI/4; h.add(roof);
                h.position.set(x, 0, z);
                scene.add(h); objects.push(h); walls.userData = { type: 'wood', originalColor: 0x8B4513 };
                updateHUD(); showMessage("Zbudowano Dom!", "gold");
                // Stw√≥rz bezpiecznƒÖ strefƒô
                const zoneBox = new THREE.Box3().setFromObject(h);
                safeZones.push(zoneBox);
            } else showMessage("Brak plan√≥w domu!", "red");
        }
        function buildFence(x, z) {
            if(player.fencePlans > 0) {
                player.fencePlans--;
                const f = new THREE.Mesh(new THREE.BoxGeometry(10, 3, 1), new THREE.MeshLambertMaterial({color: 0x8B4513}));
                f.position.set(x, 1.5, z);
                scene.add(f); objects.push(f); f.userData = { type: 'wood', originalColor: 0x8B4513 };
                updateHUD(); showMessage("Postawiono P≈Çot", "brown");
            } else showMessage("Brak schematu p≈Çotu!", "red");
        }

        function updateInventoryDisplay() {
            const list = document.getElementById('inventory-list');
            list.innerHTML = '';
            if(player.housePlans > 0) addInvItem('Dom', () => equipPlan('house'));
            if(player.fencePlans > 0) addInvItem('P≈Çot', () => equipPlan('fence'));
            if(player.arrows > 0) addInvItem('Zwyk≈Çe Strza≈Çy', () => equipArrow('regular'));
            if(player.explosiveArrows > 0) addInvItem('Wybuchowe Strza≈Çy', () => equipArrow('explosive'));
            if(player.poisonArrows > 0) addInvItem('TrujƒÖce Strza≈Çy', () => equipArrow('poison'));
        }
        function addInvItem(name, onClick) {
            const btn = document.createElement('button');
            btn.className = 'equip-btn'; btn.innerText = name; btn.onclick = onClick;
            const div = document.createElement('div'); div.style.marginBottom='5px';
            div.innerText = name + ' '; div.appendChild(btn);
            document.getElementById('inventory-list').appendChild(div);
        }
        function equipPlan(type) { 
            player.equippedPlan = type; 
            slotPlanText.innerHTML = type === 'house' ? "PLAN<br>DOMU" : "SCHEMAT<br>P≈ÅOTU";
            slotPlanDiv.classList.add('slot-active');
        }
        function equipArrow(type) { 
            player.equippedArrow = type;
            let icon = type==='explosive' ? 'üí•' : (type==='poison' ? '‚ò†Ô∏è' : 'üèπ');
            document.querySelector('#slot-arrow .slot-icon').innerText = icon;
            slotArrowText.innerHTML = type.toUpperCase().substring(0,4) + ".<br>STRZA≈ÅA";
            slotArrowDiv.classList.add('slot-active');
        }

        function shootProjectile(startPos, targetPos, isWeb, isEnemyArrow) {
            const direction = new THREE.Vector3().subVectors(targetPos, startPos).normalize();
            const color = isWeb ? 0xFFFFFF : 0xAAAAAA;
            const geom = isWeb ? new THREE.SphereGeometry(0.5) : new THREE.BoxGeometry(0.1, 0.1, 2);
            const proj = new THREE.Mesh(geom, new THREE.MeshBasicMaterial({ color: color }));
            proj.position.copy(startPos);
            proj.lookAt(targetPos);
            proj.userData = { 
                velocity: direction.multiplyScalar(isWeb ? 15 : 25), 
                isWeb: isWeb, 
                isEnemyArrow: isEnemyArrow,
                startPosition: startPos.clone(),
                maxRangeSq: 50*50,
                type: 'projectile'
            };
            scene.add(proj);
            projectiles.push(proj);
        }
        
        function updateProjectiles(delta) {
            const pBox = new THREE.Box3().setFromCenterAndSize(camera.position, new THREE.Vector3(1, 4, 1)); 
            const mobBoxes = mobs.map(mob => new THREE.Box3().setFromObject(mob));

            for (let i = projectiles.length - 1; i >= 0; i--) {
                const proj = projectiles[i];
                proj.position.add(proj.userData.velocity.clone().multiplyScalar(delta));
                
                if (proj.userData.isWeb || proj.userData.isEnemyArrow) {
                    if (pBox.containsPoint(proj.position)) {
                        let inSafeZone = false;
                        for(let zone of safeZones) if(zone.containsPoint(camera.position)) inSafeZone = true;
                        
                        if(!inSafeZone) {
                            if (proj.userData.isWeb) {
                                slowEndTime = performance.now() + 5000; slowOverlay.style.display = 'block';
                                showMessage("Spowolnienie!", "green");
                            } else {
                                let dmg = SKELETON_ATTACK_DAMAGE;
                                if (player.hasIronArmor) dmg *= 0.5;
                                else if (player.hasArmor) dmg *= 0.75;
                                player.health -= dmg;
                                showMessage("Trafienie!", "red");
                                if(player.health<=0) handleGameOver();
                            }
                        }
                        scene.remove(proj); projectiles.splice(i, 1); continue;
                    }
                } 
                else if (proj.userData.type === 'player_projectile') {
                    let hit = false;
                    for (let j = mobs.length - 1; j >= 0; j--) {
                        if (mobBoxes[j].containsPoint(proj.position)) {
                            const mob = mobs[j];
                            if (proj.userData.isPoison) {
                                createGasCloud(mob.position.clone());
                                scene.remove(proj); projectiles.splice(i, 1);
                                hit = true; break;
                            }
                            const dmg = proj.userData.isExplosive ? EXPLOSIVE_ARROW_DAMAGE : REGULAR_ARROW_DAMAGE;
                            mob.userData.health -= dmg; showMessage(`Trafienie! -${dmg} HP`, "red");
                            if (mob.userData.health <= 0) killMob(mob);
                            scene.remove(proj); projectiles.splice(i, 1); hit = true; break;
                        }
                    }
                    if (hit) continue;
                    if (proj.position.y < 1 || (proj.userData.isPoison && proj.position.y < 2)) { 
                        if (proj.userData.isPoison) createGasCloud(proj.position.clone());
                        scene.remove(proj); projectiles.splice(i, 1); continue; 
                    }
                }
                if (proj.position.distanceToSquared(proj.userData.startPosition) > proj.userData.maxRangeSq) {
                    scene.remove(proj); projectiles.splice(i, 1);
                }
            }
        }

        function createGasCloud(position) {
            const geometry = new THREE.SphereGeometry(10, 16, 16);
            const material = new THREE.MeshBasicMaterial({ color: 0x00FF00, transparent: true, opacity: 0.3, side: THREE.DoubleSide });
            const cloud = new THREE.Mesh(geometry, material); cloud.position.copy(position); scene.add(cloud);
            gasClouds.push({ mesh: cloud, creationTime: performance.now() });
        }
        
        function handleGameOver() {
            isGameOver = true; document.exitPointerLock();
            createDeathBlock(camera.position.x, camera.position.z, JSON.parse(JSON.stringify(player))); 
            player = JSON.parse(JSON.stringify(INITIAL_PLAYER_STATE));
            blockerTitle.innerText = "KONIEC GRY!";
            blockerMessage.innerHTML = "Wykop niebieski blok, by odzyskaƒá rzeczy.<br>Kliknij, by zagraƒá.";
            blocker.style.display = 'flex';
        }

        function animate() {
            requestAnimationFrame(animate);
            const time = performance.now();
            const delta = (time - prevTime) / 1000;
            prevTime = time;

            if (document.pointerLockElement === document.body && !isGameOver) {
                checkSpawns(time);

                if (isChargingBowQ) { 
                    const factor = Math.min(1, (time - bowChargeStartTime)/1000/MAX_CHARGE_TIME);
                    bowChargeBar.style.width = `${factor * 100}%`;
                }

                let inSafeZone = false;
                for(let zone of safeZones) { if(zone.containsPoint(camera.position)) inSafeZone = true; }

                for (let i = gasClouds.length - 1; i >= 0; i--) {
                    const c = gasClouds[i];
                    if (time - c.creationTime > 10000) { scene.remove(c.mesh); gasClouds.splice(i, 1); continue; }
                    if (Math.floor(time) % 60 === 0) {
                        mobs.forEach(m => {
                            if (m.position.distanceTo(c.mesh.position) < 10) {
                                m.userData.health -= 1;
                                if(m.userData.health <= 0) killMob(m);
                            }
                        });
                    }
                }

                if(inSafeZone) {
                    slowEndTime = 0; slowOverlay.style.display = 'none';
                } else {
                    let hungerRate = BASE_HUNGER_DEPLETION_RATE;
                    if(player.hunger > 0) {
                        player.hunger -= hungerRate * delta; if(player.hunger<=0) player.hunger=0;
                        if(Math.floor(time)%2==0) updateHUD();
                    } else {
                        player.health -= 5 * delta; if(player.health<=0) handleGameOver(); updateHUD();
                    }
                }

                updateProjectiles(delta);

                velocity.x -= velocity.x * 10.0 * delta;
                velocity.z -= velocity.z * 10.0 * delta;
                velocity.y -= 9.8 * 100.0 * delta; 
                direction.z = Number(moveForward) - Number(moveBackward);
                direction.x = Number(moveRight) - Number(moveLeft);
                direction.normalize(); 

                let currentSpeed = BASE_SPEED;
                if (player.hasIronArmor) currentSpeed *= IRON_ARMOR_PENALTY; 
                if (time < slowEndTime) currentSpeed *= WEB_SLOW_FACTOR; else slowOverlay.style.display = 'none';

                if (moveForward || moveBackward) velocity.z -= direction.z * currentSpeed * delta;
                if (moveLeft || moveRight) velocity.x -= direction.x * currentSpeed * delta;

                const fwd = new THREE.Vector3(); camera.getWorldDirection(fwd); fwd.y = 0; fwd.normalize();
                const right = new THREE.Vector3(); right.crossVectors(fwd, new THREE.Vector3(0, 1, 0)).normalize();
                
                camera.position.x -= (right.x * velocity.x + fwd.x * velocity.z) * delta;
                camera.position.z -= (right.z * velocity.x + fwd.z * velocity.z) * delta;
                camera.position.y += velocity.y * delta;

                if (camera.position.y < PLAYER_HEIGHT) { velocity.y = 0; camera.position.y = PLAYER_HEIGHT; canJump = true; }

                mobs.forEach(mob => {
                    const data = mob.userData;
                    let dx=0, dz=0;
                    let mobSpeed = data.walkSpeed;
                    if (time < data.slowEndTime) mobSpeed *= 0.7; 

                    let pushed = false;
                    for (let zone of safeZones) {
                        const center = new THREE.Vector3(); zone.getCenter(center);
                        const size = new THREE.Vector3(); zone.getSize(size);
                        const repelDist = (Math.max(size.x, size.z) / 2) + 10;
                        if (mob.position.distanceTo(center) < repelDist) {
                            const pushDir = mob.position.clone().sub(center).normalize();
                            dx = pushDir.x * mobSpeed * delta; dz = pushDir.z * mobSpeed * delta;
                            pushed = true;
                            if (zone.containsPoint(mob.position)) mob.position.add(pushDir.multiplyScalar(5));
                        }
                    }

                    if (!pushed) {
                         if (data.type === 'cow') {
                            if (time > data.nextTurnTime) {
                                data.walkDirection.set(Math.random()-0.5, 0, Math.random()-0.5).normalize();
                                data.nextTurnTime = time + 2000;
                                mob.rotation.y = Math.atan2(data.walkDirection.x, data.walkDirection.z);
                            }
                            dx = data.walkDirection.x * mobSpeed * delta;
                            dz = data.walkDirection.z * mobSpeed * delta;
                        } else {
                            const pPos = camera.position.clone();
                            const dist = mob.position.distanceTo(pPos);
                            mob.rotation.y = Math.atan2(pPos.x - mob.position.x, pPos.z - mob.position.z);
                            
                            if (data.type === 'skeleton') {
                                if (dist > SKELETON_RANGE) { const d = pPos.sub(mob.position).normalize(); dx = d.x*mobSpeed*delta; dz = d.z*mobSpeed*delta; }
                                if (dist <= SKELETON_RANGE + 10 && time > data.lastAttackTime + data.attackCooldown) {
                                    shootProjectile(mob.position, camera.position, false, true); data.lastAttackTime = time;
                                }
                            } else if (data.type === 'spider') {
                                if (dist > 20) { const d = pPos.sub(mob.position).normalize(); dx = d.x*mobSpeed*delta; dz = d.z*mobSpeed*delta; }
                                if (dist <= 30 && time > data.lastAttackTime + data.attackCooldown) {
                                    shootProjectile(mob.position, camera.position, true, false); data.lastAttackTime = time;
                                }
                            } else if (data.type === 'zombie') {
                                if (dist > 2.5) { const d = pPos.sub(mob.position).normalize(); dx = d.x*mobSpeed*delta; dz = d.z*mobSpeed*delta; }
                                else if (time > data.lastAttackTime + data.attackCooldown) {
                                    let dmg = ZOMBIE_ATTACK_DAMAGE;
                                    if(player.hasIronArmor) dmg *= 0.5;
                                    else if(player.hasArmor) dmg *= 0.75;
                                    player.health -= dmg;
                                    showMessage("Ugryzienie!", "red"); data.lastAttackTime = time;
                                    if(player.health<=0) handleGameOver();
                                }
                            }
                        }
                    }
                    mob.position.x += dx; mob.position.z += dz;
                });
            }
            renderer.render(scene, camera);
        }
        function onWindowResize() { camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); }
    </script>
</body>
</html>
