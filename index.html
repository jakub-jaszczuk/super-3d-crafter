<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Symulator Craftingu 3D - Diamond & Fence Update</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            user-select: none;
        }

        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 20px;
            height: 20px;
            background-color: transparent;
            border: 2px solid rgba(255, 255, 255, 0.8);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            z-index: 10;
            pointer-events: none;
        }
        #crosshair::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 4px;
            height: 4px;
            background-color: white;
            transform: translate(-50%, -50%);
        }

        /* ZASOBY - teraz w kolumnie nad przedmiotami */
        #hud {
            position: absolute;
            bottom: 150px; /* Podniesione, aby zrobiƒá miejsce na #items-display */
            left: 20px;
            color: white;
            font-size: 14px;
            background: rgba(0, 0, 0, 0.5);
            padding: 15px;
            border-radius: 8px;
            pointer-events: none;
            min-width: 200px;
            line-height: 1.6;
        }
        
        /* WY≈öWIETLANIE PRZEDMIOT√ìW (narzƒôdzia/zbroja) */
        #items-display {
            position: absolute;
            bottom: 50px; /* Pozycja pod #hud */
            left: 20px;
            display: flex;
            gap: 8px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 8px;
            pointer-events: none;
            max-width: 300px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            flex-wrap: wrap; /* Zezwala na zawijanie ikon */
        }

        .item-icon {
            font-size: 20px;
            padding: 5px;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid #555;
            border-radius: 4px;
            color: white;
            position: relative;
        }
        
        /* Wyr√≥≈ºnienie aktywnie wyposa≈ºonego przedmiotu */
        .item-equipped {
            border-color: #00FF00 !important;
            box-shadow: 0 0 10px #00FF00;
        }

        /* Kolory ramek dla poszczeg√≥lnych materia≈Ç√≥w */
        .item-wood { border-color: #8B4513; }
        .item-stone { border-color: #808080; }
        .item-iron { border-color: #D3D3D3; }
        .item-diamond { border-color: #00FFFF; }
        .item-poison { border-color: #2E8B57; }
        .item-armor-base { border-color: #5F9EA0; }
        .item-armor-iron { border-color: #708090; }
        .item-bow { border-color: #5C4033; }


        #quick-slots-container {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 20px;
            z-index: 15;
            pointer-events: none;
        }

        .quick-slot {
            width: 80px;
            height: 80px;
            background: rgba(0, 0, 0, 0.6);
            border: 3px solid #888;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 12px;
            text-align: center;
        }
        
        /* Specyficzne kszta≈Çty slot√≥w */
        #slot-arrow { border-radius: 50%; }
        #slot-plan, #slot-spell { border-radius: 8px; }

        .slot-active {
            border-color: #00FF00;
            background: rgba(0, 50, 0, 0.6);
        }

        .slot-icon {
            font-size: 24px;
            margin-bottom: 5px;
            font-weight: bold;
        }
        
        /* Czas odnowienia zaklƒôƒá */
        #spell-cooldown-display {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 8px;
            display: none;
            align-items: center;
            justify-content: center;
            color: cyan;
            font-size: 18px;
            font-weight: bold;
        }


        #health-container {
            position: absolute;
            bottom: 60px; 
            right: 20px;
            width: 200px;
            height: 30px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 5px;
            overflow: hidden;
            border: 2px solid #fff;
            padding: 2px;
            box-sizing: border-box;
            pointer-events: none;
        }

        #health-bar {
            height: 100%;
            width: 100%; 
            background: linear-gradient(to right, #00FF00, #008000); 
            transition: width 0.1s;
            border-radius: 3px;
        }

        #health-text {
            position: absolute;
            width: 100%;
            height: 100%;
            line-height: 26px; 
            text-align: center;
            color: white;
            font-weight: bold;
            text-shadow: 1px 1px 2px #000;
        }
        
        #hunger-container {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 200px;
            height: 30px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 5px;
            overflow: hidden;
            border: 2px solid #fff;
            padding: 2px;
            box-sizing: border-box;
            pointer-events: none;
        }

        #hunger-bar {
            height: 100%;
            width: 100%; 
            background: linear-gradient(to right, #FFA500, #FF4500); 
            transition: width 0.1s;
            border-radius: 3px;
        }
        
        #hunger-text {
            position: absolute;
            width: 100%;
            height: 100%;
            line-height: 26px; 
            text-align: center;
            color: white;
            font-weight: bold;
            text-shadow: 1px 1px 2px #000;
        }

        #bow-charge {
            position: absolute;
            top: 40%;
            left: 50%;
            transform: translateX(-50%);
            width: 100px;
            height: 10px;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 5px;
            overflow: hidden;
            display: none; 
        }
        #bow-charge-bar {
            height: 100%;
            width: 0%;
            background: linear-gradient(to right, #6CFF5E, #4CAF50);
        }

        #message-area {
            position: absolute;
            top: 60%; 
            left: 50%;
            transform: translateX(-50%);
            color: #ff5555;
            font-size: 20px;
            font-weight: bold;
            text-shadow: 1px 1px 2px black;
            opacity: 0;
            transition: opacity 0.2s;
            pointer-events: none;
            text-align: center;
            width: 80%;
        }
        
        #slow-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            box-shadow: inset 0 0 100px rgba(100, 255, 100, 0.5);
            pointer-events: none;
            display: none;
            z-index: 5;
        }

        .explosion-effect {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 300px; 
            height: 300px;
            background: radial-gradient(circle, rgba(255, 165, 0, 0.9) 0%, rgba(255, 69, 0, 0.8) 50%, rgba(255, 0, 0, 0) 100%);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            opacity: 0;
            transition: opacity 0.1s, transform 0.1s;
            pointer-events: none;
            z-index: 50;
        }

        #blocker {
            position: absolute;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 20;
            color: white;
            text-align: center;
        }

        .game-menu {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(40, 40, 40, 0.95);
            padding: 20px;
            border-radius: 10px;
            border: 2px solid #555;
            color: white;
            z-index: 30;
            width: 500px; 
            max-width: 95vw;
            text-align: center;
            max-height: 80vh;
            overflow-y: auto;
        }

        .craft-btn {
            display: block;
            width: 100%;
            padding: 8px; 
            margin: 5px 0;
            background: #4CAF50;
            border: none;
            color: white;
            cursor: pointer;
            font-size: 14px;
            border-radius: 5px;
        }
        .craft-btn:disabled {
            background: #555;
            cursor: not-allowed;
            opacity: 0.6;
        }
        .craft-btn:hover:not(:disabled) {
            background: #45a049;
        }
        
        .equip-btn {
            background-color: #2196F3;
            color: white;
            border: none;
            padding: 5px 10px;
            margin-left: 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }
        .equip-btn:hover { background-color: #0b7dda; }

        h1, h2 { margin-top: 0; }
        
        .key {
            background: #eee;
            color: #333;
            padding: 2px 6px;
            border-radius: 4px;
            font-weight: bold;
        }

        #inventory-list {
            text-align: left;
            margin-top: 20px;
            line-height: 1.5;
            border-top: 1px solid #555;
            padding-top: 10px;
        }
        
        .inventory-section {
            margin-top: 15px;
            border-bottom: 1px dashed #555;
            padding-bottom: 10px;
        }

        .inventory-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 5px 0;
        }

        .item-info {
            display: flex;
            align-items: center;
        }

        .item-status {
            font-size: 10px;
            color: #ccc;
            margin-left: 10px;
        }
        
        .equipped-status {
            color: #00FF00;
            font-weight: bold;
        }
    </style>
</head>
<body>

    <!-- UI -->
    <div id="crosshair"></div>
    <div id="slow-overlay"></div>
    
    <div id="hud"></div> 
    <div id="items-display"></div> <!-- Kontener na posiadane narzƒôdzia/bro≈Ñ/zbrojƒô -->
    
    <div id="quick-slots-container">
        <div id="slot-plan" class="quick-slot">
            <div class="slot-icon">üè†</div>
            <div id="slot-plan-text">BRAK<br>SCHEMATU</div>
        </div>
        <div id="slot-arrow" class="quick-slot">
            <div class="slot-icon">üèπ</div>
            <div id="slot-arrow-text">BRAK<br>STRZA≈ÅY</div>
        </div>
        <div id="slot-spell" class="quick-slot"> <!-- NOWY SLOT -->
            <div id="spell-cooldown-display">10s</div>
            <div class="slot-icon">‚ú®</div>
            <div id="slot-spell-text">BRAK<br>ZAKLƒòCIA</div>
        </div>
    </div>
    
    <div id="health-container">
        <div id="health-bar"></div>
        <div id="health-text">≈ªycie: 100%</div>
    </div>
    
    <div id="hunger-container">
        <div id="hunger-bar"></div>
        <div id="hunger-text">G≈Ç√≥d: 100%</div>
    </div>
    
    <div id="bow-charge">
        <div id="bow-charge-bar"></div>
    </div>

    <div id="message-area">Wiadomo≈õƒá</div>
    <div id="explosion-overlay" class="explosion-effect"></div>

    <div id="blocker">
        <h1 id="blocker-title">Symulator Craftingu 3D</h1>
        <p id="blocker-message">Kliknij, aby zagraƒá</p>
        <p><strong>UWAGA:</strong> Muzyka w tle (Dark Souls 3) nie jest obs≈Çugiwana ze wzglƒôdu na ograniczenia bezpiecze≈Ñstwa ≈Çadowania zewnƒôtrznych plik√≥w audio. </p>
        <p><strong>NOWE:</strong> Masz ju≈º DrewnianƒÖ Siekierƒô! U≈ºyj <span class="key">1</span>, <span class="key">2</span>, <span class="key">3</span> do szybkiej zmiany narzƒôdzi. <span class="key">F</span> - u≈ºycie zaklƒôcia (10s CD).</p>
        <p><strong>WA≈ªNE:</strong> Potwory (Zbrojny Szkielet!) pojawiƒÖ siƒô dopiero po stworzeniu zbroi!</p>
        <p>Sterowanie: <span class="key">W</span><span class="key">A</span><span class="key">S</span><span class="key">D</span> - Chodzenie | <span class="key">SPACJA</span> - Skok</p>
        <p><span class="key">LPM</span> - Atak/Wydobycie (tylko z wyposa≈ºonym narzƒôdziem!) | <span class="key">PPM</span> - Budowanie</p>
        <p><span class="key">E</span> - Crafting | <span class="key">I</span> - Ekwipunek (Wyposa≈ºanie)</p>
    </div>
    
    <!-- Dodatkowy element Audio (Placeholder) -->
    <audio id="background-music" loop autoplay>
        Twoja przeglƒÖdarka nie obs≈Çuguje elementu audio.
    </audio>

    <!-- Menu Craftingu (E) -->
    <div id="crafting-menu" class="game-menu">
        <h2>Menu Craftingu</h2>
        <p>Naci≈õnij <span class="key">E</span> lub <span class="key">ESC</span> aby zamknƒÖƒá</p>
        <div style="border-top: 1px solid #555; margin: 10px 0;"></div>
        
        <button id="btn-planks" class="craft-btn">Deski (4) (1 Drewno)</button>
        <button id="btn-house-plans" class="craft-btn" style="background-color: #FFA07A; color: black;">Plany Domu (20 Dr., 20 Kam.)</button>
        <button id="btn-fence-plans" class="craft-btn" style="background-color: #8B4513;">Schemat P≈Çotu (12 Desek)</button>

        <hr>
        
        <button id="btn-wood-pick" class="craft-btn">Drewniany Kilof (3 Drewna)</button>
        <button id="btn-stone-pick" class="craft-btn">Kamienny Kilof (2 Dr., 1 Kam.)</button>
        <button id="btn-iron-pick" class="craft-btn">≈ªelazny Kilof (2 Dr., 1 ≈ªel.)</button>
        <button id="btn-diamond-pick" class="craft-btn" style="background-color: #9370DB;">Diamentowy Kilof (2 Dr., 3 Diam.)</button>
        
        <button id="btn-diamond-axe" class="craft-btn" style="background-color: #9370DB;">Diamentowa Siekiera (2 Dr., 3 Diam.)</button>

        <hr>

        <button id="btn-black-ink" class="craft-btn" title="Mo≈ºna stworzyƒá tylko raz.">Czarny Atrament (1) (2 Wƒôgiel, 2 Diam.)</button>
        <button id="btn-repulsion-scroll" class="craft-btn" style="background-color: #8A2BE2;" title="Mo≈ºna stworzyƒá tylko raz.">Zw√≥j Odpychania (4 Diam., 10 Nici)</button>
        <button id="btn-fire-aura-scroll" class="craft-btn" style="background-color: #FF4500;" title="Mo≈ºna stworzyƒá tylko raz.">Zw√≥j Ognistej Aury (1 Czarny Atrament, 10 Nici)</button>
        <button id="btn-trap-scroll" class="craft-btn" style="background-color: #795548;" title="Mo≈ºna stworzyƒá tylko raz.">Zw√≥j Pu≈Çapki (5 ≈ªelazo, 10 Nici)</button> 
        <button id="btn-teleport-scroll" class="craft-btn" style="background-color: #4B0082;" title="Mo≈ºna stworzyƒá tylko raz.">Zw√≥j Teleportacji (3 Diam., 2 Wƒôgiel)</button> 

        <hr>

        <button id="btn-stone-sword" class="craft-btn">Kamienny Miecz (2 Kam., 1 Dr.)</button>
        <button id="btn-iron-sword" class="craft-btn">≈ªelazny Miecz (2 ≈ªel., 1 Dr.)</button>
        <button id="btn-poison-sword" class="craft-btn">Zatruty Miecz (≈ªel. Miecz + 1 Jad)</button>
        <button id="btn-diamond-sword" class="craft-btn" style="background-color: #9370DB;">Diamentowy Miecz (1 Dr., 2 Diam.)</button>

        <hr>
        
        <button id="btn-bow" class="craft-btn">≈Åuk (3 Nici, 3 Drewna)</button>
        <button id="btn-arrows" class="craft-btn">Strza≈Çy (5) (1 Kam., 1 Dr.)</button>
        <button id="btn-explosive-arrows" class="craft-btn">Wybuchowe Strza≈Çy (5) (1 Strz., 1 Siar.)</button>
        <button id="btn-poison-arrow" class="craft-btn" style="background-color: #32CD32; color: black;">TrujƒÖca Strza≈Ça (1 Jad, 1 Wyb. Strz.)</button>

        <hr>

        <button id="btn-armor" class="craft-btn" style="background-color: #5F9EA0;">Zbroja Sk√≥rzana (10 Sk√≥ry)</button>
        <button id="btn-iron-armor" class="craft-btn" style="background-color: #708090;">≈ªelazna Zbroja (10 ≈ªelaza)</button>
    </div>
    
    <!-- Menu Ekwipunku (I) -->
    <div id="inventory-menu" class="game-menu">
        <h2>Ekwipunek</h2>
        <p>Wyposa≈º narzƒôdzie/bro≈Ñ, aby m√≥c z niego korzystaƒá. Obecnie w rƒôce: <span id="current-tool-display" style="font-weight: bold; color: #00FF00;">Brak</span></p>
        <div id="inventory-list"></div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        // Funkcje pomocnicze przeniesione na g√≥rƒô, aby uniknƒÖƒá b≈Çƒôd√≥w inicjalizacji
        function getRandomDropAmount() { return Math.floor(Math.random() * 3) + 1; }
        const toolOwned = (id) => player[id + '_owned'];

        let camera, scene, renderer;
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
        let canJump = false, isGameOver = false;
        let slowEndTime = 0; 

        let prevTime = performance.now();
        const velocity = new THREE.Vector3();
        const direction = new THREE.Vector3();
        
        const PLAYER_HEIGHT = 10; 
        const BASE_SPEED = 400.0;
        const JUMP_VELOCITY = 500; 
        const VIEW_DISTANCE = 2000; 
        const FOG_END = 500; 
        const BASE_HUNGER_DEPLETION_RATE = 0.5;
        const SPELL_COOLDOWN = 10000; // 10 sekund cooldown na zaklƒôcia
        let lastSpellTime = 0;
        const spellCooldownDisplay = document.getElementById('spell-cooldown-display');


        const IRON_ARMOR_PENALTY = 0.75; 
        const WEB_SLOW_FACTOR = 0.3;
        
        const ZOMBIE_ATTACK_DAMAGE = 1; 
        const SKELETON_BOW_DAMAGE = 1;
        
        // --- TOOL/WEAPON DATA (Damage/Strength) ---
        const TOOL_DATA = {
            'bare_hands': { type: 'none', strength: 0, damage: 1 },
            'wooden_pickaxe': { type: 'pickaxe', strength: 1, mat: 'wood', damage: 1, name: 'Drewniany Kilof' },
            'stone_pickaxe': { type: 'pickaxe', strength: 2, mat: 'stone', damage: 1, name: 'Kamienny Kilof' },
            'iron_pickaxe': { type: 'pickaxe', strength: 3, mat: 'iron', damage: 1, name: '≈ªelazny Kilof' },
            'diamond_pickaxe': { type: 'pickaxe', strength: 5, mat: 'diamond', damage: 1, name: 'Diamentowy Kilof' },
            'wooden_axe': { type: 'axe', strength: 1, mat: 'wood', damage: 1, name: 'Drewniana Siekiera' }, 
            'diamond_axe': { type: 'axe', strength: 5, mat: 'diamond', damage: 1, name: 'Diamentowa Siekiera' },
            'stone_sword': { type: 'sword', strength: 1, mat: 'stone', damage: 3, name: 'Kamienny Miecz' },
            'iron_sword': { type: 'sword', strength: 1, mat: 'iron', damage: 5, name: '≈ªelazny Miecz' },
            'poison_sword': { type: 'sword', strength: 1, mat: 'poison', damage: 5, name: 'Zatruty Miecz' },
            'diamond_sword': { type: 'sword', strength: 1, mat: 'diamond', damage: 10, name: 'Diamentowy Miecz' },
            'bow': { type: 'bow', strength: 1, mat: 'bow', damage: 1, name: '≈Åuk' },
            'armor': { type: 'armor', name: 'Zbroja Sk√≥rzana' },
            'iron_armor': { type: 'armor', name: '≈ªelazna Zbroja' },
        };
        const REGULAR_ARROW_DAMAGE = 5; 
        const EXPLOSIVE_ARROW_DAMAGE = 10; 
        // -----------------------------------------

        // SPELL CONSTANTS
        const FIRE_AURA_DURATION = 20000; 
        const FIRE_AURA_DAMAGE_PER_SEC = 2;
        const FIRE_AURA_RANGE = 20; 
        const FIRE_AURA_RANGE_SQ = FIRE_AURA_RANGE * FIRE_AURA_RANGE; 
        const REPULSION_CAST_RANGE = 45;
        const REPULSION_PUSH_FORCE = 50; 
        const TELEPORT_DISTANCE = 100; // Teleportuje 100 blok√≥w do przodu
        const TRAP_DURATION = 10000; 

        let isFireAuraActive = false;
        let fireAuraEndTime = 0;
        let lastAuraDamageTime = 0;
        const activeTraps = []; 

        const MAX_COWS = 15; const MAX_MOBS = 10; const MAX_SPIDERS = 5; const MAX_SKELETONS = 5;
        const SKELETON_RANGE = 50; 

        const INITIAL_PLAYER_STATE = {
            wood: 0, stone: 0, iron: 0, sulphur: 0, diamonds: 0,
            meat: 0, leather: 0, string: 0, venom: 0,
            arrows: 0, explosiveArrows: 0, poisonArrows: 0, 
            saplings: 0, housePlans: 0, fencePlans: 0, planks: 0,
            health: 100, hunger: 100,
            
            // NOWE ZASOBY I ZWOJE
            coal: 0, 
            blackInk: 0,
            repulsionScrolls: 0, 
            fireAuraScrolls: 0,
            trapScrolls: 0, 
            teleportScrolls: 0, 
            
            // W≈ÅASNO≈öƒÜ ZWOJ√ìW (tylko jeden raz)
            repulsionScroll_owned: false,
            fireAuraScroll_owned: false,
            trapScroll_owned: false,
            teleportScroll_owned: false,
            
            // W≈ÅASNO≈öƒÜ NARZƒòDZI/PRZEDMIOT√ìW 
            wooden_pickaxe_owned: false, stone_pickaxe_owned: false, iron_pickaxe_owned: false, diamond_pickaxe_owned: false,
            stone_sword_owned: false, iron_sword_owned: false, poison_sword_owned: false, diamond_sword_owned: false,
            wooden_axe_owned: true, 
            diamond_axe_owned: false, bow_owned: false, armor_owned: false, iron_armor_owned: false,
            
            // AKTUALNIE WYPOSA≈ªONY PRZEDMIOT
            equippedTool: 'wooden_axe', 
            
            equippedPlan: null, equippedArrow: null, equippedSpell: null 
        };

        let player = JSON.parse(JSON.stringify(INITIAL_PLAYER_STATE)); 

        let isCraftingOpen = false;
        let isInventoryOpen = false; 
        const objects = []; 
        const mobs = [];    
        const projectiles = [];
        const gasClouds = []; 
        let safeZones = []; 
        let raycaster;
        
        let isChargingBowQ = false; 
        let bowChargeStartTime = 0;
        const MAX_CHARGE_TIME = 1.5; 
        const ARROW_MAX_RANGE = 200;

        const blocker = document.getElementById('blocker');
        const blockerTitle = document.getElementById('blocker-title');
        const blockerMessage = document.getElementById('blocker-message');
        const craftingMenu = document.getElementById('crafting-menu');
        const inventoryMenu = document.getElementById('inventory-menu');
        const messageArea = document.getElementById('message-area');
        const bowChargeBar = document.getElementById('bow-charge-bar');
        const bowChargeContainer = document.getElementById('bow-charge');
        const slowOverlay = document.getElementById('slow-overlay');
        const slotPlanText = document.getElementById('slot-plan-text');
        const slotArrowText = document.getElementById('slot-arrow-text');
        const slotPlanDiv = document.getElementById('slot-plan');
        const slotArrowDiv = document.getElementById('slot-arrow');
        const slotSpellDiv = document.getElementById('slot-spell'); 
        const slotSpellText = document.getElementById('slot-spell-text'); 
        const itemsDisplay = document.getElementById('items-display'); 
        const currentToolDisplay = document.getElementById('current-tool-display');
        
        let lastMobSpawnTime = 0, lastCowSpawnTime = 0, lastSulphurSpawnTime = 0, lastSpiderSpawnTime = 0, lastSkeletonSpawnTime = 0;
        
        document.addEventListener('contextmenu', (e) => e.preventDefault());
        
        init();
        animate();
        
        
        function init() {
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, VIEW_DISTANCE);
            camera.position.y = PLAYER_HEIGHT; 

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            scene.fog = new THREE.Fog(0x87CEEB, 0, FOG_END); 

            const light = new THREE.HemisphereLight(0xffffff, 0x444444);
            light.position.set(0, 20, 0);
            scene.add(light);
            
            const dirLight = new THREE.DirectionalLight(0xffffff);
            dirLight.position.set(50, 200, 100);
            dirLight.castShadow = true;
            scene.add(dirLight);

            const floorGeometry = new THREE.PlaneGeometry(2000, 2000, 100, 100);
            floorGeometry.rotateX(-Math.PI / 2);
            const floorMaterial = new THREE.MeshLambertMaterial({ color: 0x228B22 }); 
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            scene.add(floor);
            objects.push(floor); 

            generateTrees(60); 
            generateCaves(8);
            generateCoalOres(10); 
            generateDiamondOres(5);
            generateStringBlocks(20); 
            generateSulphurBlocks(15); 
            for(let i = 0; i < 5; i++) createCow(Math.random() * 400 - 200, Math.random() * 400 - 200); 

            raycaster = new THREE.Raycaster();
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);
            
            // PR√ìBA W≈ÅƒÑCZENIA MUZYKI W TLE
            const music = document.getElementById('background-music');
            if(music) {
                // Ta linia mo≈ºe wymagaƒá interakcji u≈ºytkownika do zadzia≈Çania
                music.volume = 0.5;
                // music.play().catch(e => console.log("Music auto-play failed. User interaction needed.", e)); 
            }

            const euler = new THREE.Euler(0, 0, 0, 'YXZ');
            document.addEventListener('mousemove', function(event) {
                if (document.pointerLockElement === document.body && !isGameOver) {
                    const movementX = event.movementX || 0;
                    const movementY = event.movementY || 0;
                    euler.setFromQuaternion(camera.quaternion);
                    euler.y -= movementX * 0.002;
                    euler.x -= movementY * 0.002;
                    euler.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, euler.x));
                    camera.quaternion.setFromEuler(euler);
                }
            });

            blocker.addEventListener('click', function() {
                if (isGameOver) resetGame();
                
                // Uruchomienie muzyki po klikniƒôciu gracza
                if (music) music.play().catch(e => console.log("Music start failed.", e));
                
                document.body.requestPointerLock();
            });

            document.addEventListener('pointerlockchange', function() {
                if (document.pointerLockElement === document.body) {
                    blocker.style.display = 'none';
                    isCraftingOpen = false; isInventoryOpen = false;
                    craftingMenu.style.display = 'none'; inventoryMenu.style.display = 'none';
                } else {
                    if(!isCraftingOpen && !isInventoryOpen) blocker.style.display = 'flex';
                }
            });

            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            document.addEventListener('mousedown', onMouseDown);
            document.addEventListener('mouseup', onMouseUp); 

            const bind = (id, fn) => document.getElementById(id).addEventListener('click', fn);
            bind('btn-planks', craftPlanks);
            bind('btn-house-plans', craftHousePlans);
            bind('btn-fence-plans', craftFencePlans);
            bind('btn-wood-pick', () => craftTool('wooden_pickaxe'));
            bind('btn-stone-pick', () => craftTool('stone_pickaxe'));
            bind('btn-iron-pick', () => craftTool('iron_pickaxe'));
            bind('btn-diamond-pick', () => craftTool('diamond_pickaxe'));
            bind('btn-diamond-axe', () => craftTool('diamond_axe'));
            bind('btn-stone-sword', () => craftTool('stone_sword'));
            bind('btn-iron-sword', () => craftTool('iron_sword'));
            bind('btn-poison-sword', craftPoisonSword);
            bind('btn-diamond-sword', () => craftTool('diamond_sword'));
            bind('btn-bow', craftBow);
            bind('btn-arrows', craftArrows);
            bind('btn-explosive-arrows', craftExplosiveArrows);
            bind('btn-poison-arrow', craftPoisonArrow);
            bind('btn-armor', () => craftArmor('armor'));
            bind('btn-iron-armor', () => craftArmor('iron_armor'));

            // NOWE ZAKLƒòCIA I ATRAMENT
            bind('btn-black-ink', craftBlackInk);
            bind('btn-repulsion-scroll', craftRepulsionScroll);
            bind('btn-fire-aura-scroll', craftFireAuraScroll);
            bind('btn-trap-scroll', craftTrapScroll); 
            bind('btn-teleport-scroll', craftTeleportScroll); 

            updateHUD();
            window.addEventListener('resize', onWindowResize);
        }
        
        function generateCoalOres(count) {
            for (let i = 0; i < count; i++) {
                const cx = Math.random() * 300 - 150; 
                const cz = Math.random() * 300 - 150;
                for (let j = 0; j < 5; j++) {
                    const m = new THREE.Mesh(new THREE.BoxGeometry(2.5, 2.5, 2.5), new THREE.MeshLambertMaterial({ color: 0x333333 })); // Dark grey/black
                    m.position.set(cx + (Math.random()-0.5)*15, (Math.random()*8)-6, cz + (Math.random()-0.5)*15);
                    m.userData = { type: 'coal_ore', originalColor: 0x333333 };
                    scene.add(m); objects.push(m);
                }
            }
        }
        
        function toggleCrafting() {
            if (isGameOver) return; 
            isCraftingOpen = !isCraftingOpen;
            if (isCraftingOpen) {
                if (isInventoryOpen) toggleInventory(); 
                document.exitPointerLock();
                craftingMenu.style.display = 'block';
                updateCraftingButtons();
            } else {
                craftingMenu.style.display = 'none';
                document.body.requestPointerLock();
            }
        }

        function toggleInventory() {
            if (isGameOver) return; 
            isInventoryOpen = !isInventoryOpen;
            if (isInventoryOpen) {
                if (isCraftingOpen) toggleCrafting(); 
                document.exitPointerLock();
                inventoryMenu.style.display = 'block';
                updateInventoryDisplay(); // WZYWA FUNKCJƒò
            } else {
                inventoryMenu.style.display = 'none';
                document.body.requestPointerLock();
            }
        }

        function showMessage(text, color) {
            messageArea.innerHTML = text; 
            messageArea.style.color = color; 
            messageArea.style.opacity = 1;
            if(messageArea.timeout) clearTimeout(messageArea.timeout);
            messageArea.timeout = setTimeout(() => messageArea.style.opacity = 0, 1500);
        }

        function eatMeat() { 
            if(player.meat>0 && (player.hunger<100 || player.health<100)) { 
                player.meat--; player.hunger=100; player.health=Math.min(100, player.health+20); 
                updateHUD(); 
                showMessage("Mniam!", "orange"); 
            }
        }

        function resetGame() {
             const keptObjects = [];
            for(let i = 1; i < objects.length; i++) {
                if (objects[i].userData.type === 'death_block') keptObjects.push(objects[i]);
                else {
                    scene.remove(objects[i]);
                    if (objects[i].userData.leaves) scene.remove(objects[i].userData.leaves);
                }
            }
            
            const floor = objects[0];
            objects.length = 0; objects.push(floor);
            keptObjects.forEach(obj => objects.push(obj));

            mobs.forEach(mob => scene.remove(mob)); mobs.length = 0;
            projectiles.forEach(proj => scene.remove(proj)); projectiles.length = 0;
            gasClouds.forEach(c => scene.remove(c.mesh)); gasClouds.length = 0;
            safeZones = [];
            activeTraps.length = 0; // RESET PU≈ÅAPEK

            // Reset aury, je≈õli aktywna
            isFireAuraActive = false;
            const auraMesh = scene.getObjectByName('fireAura');
            if(auraMesh) scene.remove(auraMesh);
            
            player = JSON.parse(JSON.stringify(INITIAL_PLAYER_STATE));
            
            generateTrees(60); generateCaves(8); generateCoalOres(10); generateDiamondOres(5); generateStringBlocks(20); generateSulphurBlocks(15);
            for(let i = 0; i < 5; i++) createCow(Math.random() * 400 - 200, Math.random() * 400 - 200);

            isGameOver = false; slowEndTime = 0; slowOverlay.style.display = 'none';
            blockerTitle.innerText = "Symulator Craftingu 3D";
            blockerMessage.innerHTML = "Wykop niebieski blok, by odzyskaƒá rzeczy.<br>Kliknij, by zaczƒÖƒá od nowa.";
            camera.position.set(0, PLAYER_HEIGHT, 0); velocity.set(0, 0, 0);
            updateHUD();
        }
        
        function generateDiamondOres(count) {
            for (let i = 0; i < count; i++) {
                const cx = Math.random() * 300 - 150; 
                const cz = Math.random() * 300 - 150;
                for (let j = 0; j < 3; j++) {
                    const m = new THREE.Mesh(new THREE.BoxGeometry(2.5, 2.5, 2.5), new THREE.MeshLambertMaterial({ color: 0x800080 })); // Purple
                    m.position.set(cx + (Math.random()-0.5)*10, (Math.random()*10)-4, cz + (Math.random()-0.5)*10);
                    m.userData = { type: 'diamond_ore', originalColor: 0x800080 };
                    scene.add(m); objects.push(m);
                }
            }
        }
        
        // Zaktualizowana funkcja dla bardziej realistycznych drzew
        function generateTrees(count) {
            const scale = 1.5;
            const trunkHeight = PLAYER_HEIGHT * scale;
            // Pie≈Ñ: lekko zwƒô≈ºajƒÖcy siƒô cylinder (mniej blokowy)
            const trunkGeom = new THREE.CylinderGeometry(0.5 * scale, 1.0 * scale, trunkHeight, 8); 
            
            // Li≈õcie: Kszta≈Çt sto≈ºka dla bardziej naturalnego wyglƒÖdu
            const leavesGeom = new THREE.ConeGeometry(4 * scale, 6 * scale, 16); 
            
            for (let i = 0; i < count; i++) {
                const x = Math.random() * 400 - 200; const z = Math.random() * 400 - 200;
                
                const trunk = new THREE.Mesh(trunkGeom, new THREE.MeshLambertMaterial({ color: 0x8B4513 }));
                trunk.position.set(x, trunkHeight / 2, z); 
                trunk.userData = { type: 'wood', originalColor: 0x8B4513 };
                scene.add(trunk); objects.push(trunk);
                
                const leaves = new THREE.Mesh(leavesGeom, new THREE.MeshLambertMaterial({ color: 0x2E8B22 }));
                leaves.position.set(x, trunkHeight + (2 * scale), z); 
                scene.add(leaves);
                
                trunk.userData.leaves = leaves; 
            }
        }
        function generateCaves(count) {
            for (let i = 0; i < count; i++) {
                const cx = Math.random() * 300 - 150; const cz = Math.random() * 300 - 150;
                for (let j = 0; j < 30; j++) {
                    const isIron = Math.random() < 0.3; 
                    const m = new THREE.Mesh(new THREE.BoxGeometry(2.5, 2.5, 2.5), new THREE.MeshLambertMaterial({ color: isIron ? 0x964B00 : 0x808080 }));
                    m.position.set(cx + (Math.random()-0.5)*20, (Math.random()*11)-4, cz + (Math.random()-0.5)*20);
                    m.userData = { type: isIron ? 'iron_ore' : 'stone', originalColor: isIron ? 0x964B00 : 0x808080 };
                    scene.add(m); objects.push(m);
                }
            }
        }
        function generateStringBlocks(count) {
            for (let i = 0; i < count; i++) {
                const b = new THREE.Mesh(new THREE.BoxGeometry(3.5, 3.5, 3.5), new THREE.MeshLambertMaterial({ color: 0xFFFFFF }));
                b.position.set(Math.random() * 400 - 200, 1.75, Math.random() * 400 - 200);
                b.userData = { type: 'string_block', originalColor: 0xFFFFFF };
                scene.add(b); objects.push(b);
            }
        }
        function generateSulphurBlocks(count) { 
            for (let i = 0; i < count; i++) spawnSulphurBlock(Math.random() * 400 - 200, Math.random() * 400 - 200); 
        }
        function spawnSulphurBlock(x, z) {
            const block = new THREE.Mesh(new THREE.BoxGeometry(4, 4, 4), new THREE.MeshLambertMaterial({ color: 0xFFFF00 }));
            block.position.set(x, 2, z); block.userData = { type: 'sulphur_ore', originalColor: 0xFFFF00 };
            scene.add(block); objects.push(block);
        }
        function createDeathBlock(x, z, loot) {
            const block = new THREE.Mesh(new THREE.BoxGeometry(5, 5, 5), new THREE.MeshLambertMaterial({ color: 0x0000FF }));
            block.position.set(x, 2.5, z); block.userData = { type: 'death_block', loot: loot, originalColor: 0x0000FF };
            scene.add(block); objects.push(block);
        }

        // --- MOB GENERATION ---
        function createCow(x, z) {
            const g = new THREE.Group();
            g.position.set(x, 0, z);
            g.rotation.y = Math.random() * Math.PI * 2;
            
            const brownMat = new THREE.MeshLambertMaterial({ color: 0x654321 }); 
            const whiteMat = new THREE.MeshLambertMaterial({ color: 0xFFFFFF }); 
            const hornMat = new THREE.MeshLambertMaterial({ color: 0xFFD700 }); 

            const bodyGeom = new THREE.CylinderGeometry(1.2, 1.5, 3.5, 8); 
            const body = new THREE.Mesh(bodyGeom, brownMat);
            body.rotation.z = Math.PI / 2; 
            body.position.y = 2.5;
            body.position.z = 0;
            g.add(body);
            
            const headGeom = new THREE.SphereGeometry(1.0, 8, 8);
            const head = new THREE.Mesh(headGeom, whiteMat);
            head.position.set(1.9, 3.0, 0); 
            g.add(head);

            const hornGeom = new THREE.ConeGeometry(0.15, 0.6, 6);
            const horn1 = new THREE.Mesh(hornGeom, hornMat);
            horn1.position.set(2.5, 3.5, 0.4);
            horn1.rotation.x = Math.PI / 2; 
            g.add(horn1);
            const horn2 = horn1.clone();
            horn2.position.set(2.5, 3.5, -0.4);
            g.add(horn2);

            const legGeom = new THREE.CylinderGeometry(0.3, 0.3, 2.5, 8);
            const legPositions = [
                {x: 0.8, z: 1.0}, {x: -0.8, z: 1.0}, 
                {x: 0.8, z: -1.0}, {x: -0.8, z: -1.0}
            ];
            legPositions.forEach(pos => {
                const leg = new THREE.Mesh(legGeom, hornMat);
                leg.position.set(pos.x, 1.25, pos.z);
                g.add(leg);
            });

            g.userData = { 
                type: 'cow', 
                originalColor: 0x654321, 
                health: 1, 
                walkDirection: new THREE.Vector3(Math.random()-0.5,0,Math.random()-0.5).normalize(), 
                walkSpeed: 10, 
                nextTurnTime: performance.now()+2000,
                body: body, head: head,
                velocity: new THREE.Vector3(0, 0, 0), isTrapped: false 
            };
            scene.add(g); mobs.push(g);
        }

        function createZombie(x, z) {
            const g = new THREE.Group();
            const h = new THREE.Mesh(new THREE.BoxGeometry(2.5, 2.5, 2.5), new THREE.MeshLambertMaterial({ color: 0x006400 })); h.position.y = 7.5;
            const b = new THREE.Mesh(new THREE.BoxGeometry(2.5, 4.5, 1.5), new THREE.MeshLambertMaterial({ color: 0x228B22 })); b.position.y = 4;
            g.add(h); g.add(b); g.position.set(x, 0, z); g.userData = { type: 'zombie', originalColor: 0x228B22, health: 10, walkSpeed: 15, attackRange: 2, attackCooldown: 1000, lastAttackTime: 0, velocity: new THREE.Vector3(0, 0, 0), isTrapped: false };
            scene.add(g); mobs.push(g);
        }

        function createSpider(x, z) {
            const g = new THREE.Group();
            const b = new THREE.Mesh(new THREE.SphereGeometry(2, 8, 8), new THREE.MeshLambertMaterial({ color: 0x111111 })); b.position.y = 2; g.add(b);
            g.position.set(x, 0, z); g.userData = { type: 'spider', originalColor: 0x111111, health: 2, walkSpeed: 18, lastAttackTime: 0, attackCooldown: 5000, velocity: new THREE.Vector3(0, 0, 0), isTrapped: false };
            scene.add(g); mobs.push(g);
        }

        function createSkeleton(x, z) {
            const g = new THREE.Group();
            const mat = new THREE.MeshLambertMaterial({ color: 0xDDDDDD });
            const h = new THREE.Mesh(new THREE.BoxGeometry(2, 2, 2), mat); h.position.y = 8;
            const b = new THREE.Mesh(new THREE.BoxGeometry(1.5, 4, 1), mat); b.position.y = 5;
            const bow = new THREE.Mesh(new THREE.BoxGeometry(0.5, 4, 0.5), new THREE.MeshLambertMaterial({ color: 0x5C4033 })); bow.position.set(1.5, 6, 1);
            g.add(h); g.add(b); g.add(bow);
            g.position.set(x, 0, z); g.userData = { type: 'skeleton', originalColor: 0xDDDDDD, health: 20, walkSpeed: 12, attackRange: SKELETON_RANGE, lastAttackTime: 0, velocity: new THREE.Vector3(0, 0, 0), isTrapped: false };
            scene.add(g); mobs.push(g);
        }
        
        function createSwordSkeleton(x, z) {
            const g = new THREE.Group();
            const mat = new THREE.MeshLambertMaterial({ color: 0xDDDDDD });
            const h = new THREE.Mesh(new THREE.BoxGeometry(2, 2, 2), mat); h.position.y = 8;
            const b = new THREE.Mesh(new THREE.BoxGeometry(1.5, 4, 1), mat); b.position.y = 5;
            
            // Sword in outstretched hand
            const swordHilt = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.5, 0.5), new THREE.MeshLambertMaterial({ color: 0x8B4513 }));
            const swordBlade = new THREE.Mesh(new THREE.BoxGeometry(0.2, 5, 0.2), new THREE.MeshLambertMaterial({ color: 0xD3D3D3 }));
            swordBlade.position.y = 2.5;
            
            const swordGroup = new THREE.Group();
            swordGroup.add(swordHilt);
            swordGroup.add(swordBlade);
            
            // Position sword (outstretched)
            swordGroup.position.set(0.5, 6, 1.5); 
            swordGroup.rotation.x = -Math.PI / 2; 

            g.add(h); g.add(b); g.add(swordGroup);
            
            g.position.set(x, 0, z); 
            g.userData = { 
                type: 'sword_skeleton', 
                originalColor: 0xDDDDDD, 
                health: 25, 
                walkSpeed: 15, 
                attackRange: 2.5, 
                attackCooldown: 1000, 
                lastAttackTime: 0, 
                velocity: new THREE.Vector3(0, 0, 0), 
                isTrapped: false,
                damage: 10, // 10 damage
                hungerAuraRange: 10, // 10 blocks
            };
            scene.add(g); mobs.push(g);
        }

        // Funkcja do pobierania statystyk wyposa≈ºonego narzƒôdzia
        function getEquippedTool() {
            return TOOL_DATA[player.equippedTool] || TOOL_DATA['bare_hands'];
        }
        
        // NOWA FUNKCJA: Znajduje najlepsze posiadane narzƒôdzie danego typu
        function getBestTool(type) {
            const tiers = {
                'pickaxe': ['diamond_pickaxe', 'iron_pickaxe', 'stone_pickaxe', 'wooden_pickaxe'],
                'axe': ['diamond_axe', 'wooden_axe'], 
                'sword': ['diamond_sword', 'poison_sword', 'iron_sword', 'stone_sword'],
            };
            
            if (!tiers[type]) return null;

            for (const id of tiers[type]) {
                if (player[id + '_owned']) {
                    return id;
                }
            }
            return null; // Brak narzƒôdzia tego typu
        }


        // --- INTERAKCJE ---
        function handleHit(object) {
            if (!object) return;
            const type = object.userData.type;
            const equippedTool = getEquippedTool();
            
            if (object.material && object.userData.originalColor) {
                object.material.color.setHex(0xffffff); setTimeout(() => object.material.color.setHex(object.userData.originalColor), 100);
            } else if (object.children && object.children[0].material) {
                object.children.forEach(m => { if(m.material) m.material.color.setHex(0xffffff); });
                setTimeout(() => object.children.forEach(m => { if(m.material) m.material.color.setHex(object.userData.originalColor); }), 100);
            }

            if (type === 'wood') {
                if (equippedTool.type !== 'axe') {
                    showMessage("Wymagana Siekiera!", "red");
                    return;
                }
                
                let amount = 1; 
                if (equippedTool.mat === 'wood') {
                    amount = getRandomDropAmount(); 
                } else if (equippedTool.mat === 'diamond') {
                    amount = 5; 
                } 
                
                player.wood += amount;
                if(Math.random() < 0.20) { player.saplings++; showMessage(`+${amount} Drewno, +SADZONKA!`, "lightgreen"); }
                else showMessage(`+${amount} Drewno`, "#4CAF50");
                scene.remove(object); if(object.userData.leaves) scene.remove(object.userData.leaves); objects.splice(objects.indexOf(object), 1);
            }
            else if (type === 'stone') {
                const hasAnyPickaxe = equippedTool.type === 'pickaxe';
                
                if(hasAnyPickaxe) {
                    let amount;
                    if (equippedTool.mat === 'diamond') amount = 5;
                    else if (equippedTool.mat === 'stone' || equippedTool.mat === 'iron') amount = getRandomDropAmount(); 
                    else if (equippedTool.mat === 'wood') amount = 1; 
                    else amount = 0;

                    player.stone += amount; 
                    showMessage(`+${amount} Kamie≈Ñ`, "#808080"); 
                    scene.remove(object); 
                    objects.splice(objects.indexOf(object), 1);
                } else showMessage("Wymagany Kilof!", "red");
            }
            else if (type === 'iron_ore') {
                if(equippedTool.mat === 'stone' || equippedTool.mat === 'iron' || equippedTool.mat === 'diamond') {
                    let amount = equippedTool.mat === 'diamond' ? 5 : getRandomDropAmount();
                    player.iron += amount; showMessage(`+${amount} ≈ªelazo`, "#D3D3D3"); scene.remove(object); objects.splice(objects.indexOf(object), 1);
                } else showMessage("Wymagany Kamienny Kilof!", "red");
            }
            else if (type === 'coal_ore') { 
                if(equippedTool.type === 'pickaxe' && equippedTool.mat !== 'wood') {
                    let amount = equippedTool.mat === 'diamond' ? 5 : getRandomDropAmount();
                    player.coal += amount; showMessage(`+${amount} Wƒôgiel`, "darkgray"); scene.remove(object); objects.splice(objects.indexOf(object), 1);
                } else showMessage("Wymagany Kamienny Kilof!", "red");
            }
            else if (type === 'diamond_ore') {
                if(equippedTool.mat === 'iron' || equippedTool.mat === 'diamond') {
                    let amount = equippedTool.mat === 'diamond' ? 5 : getRandomDropAmount();
                    player.diamonds += amount; showMessage(`+${amount} DIAMENTY!`, "#9370DB"); scene.remove(object); objects.splice(objects.indexOf(object), 1);
                } else showMessage("Wymagany ≈ªelazny Kilof!", "red");
            }
            else if (type === 'sulphur_ore') {
                if(equippedTool.type === 'pickaxe') {
                    let amount = equippedTool.mat === 'diamond' ? 5 : getRandomDropAmount();
                    player.sulphur += amount; showMessage(`+${amount} Siarka`, "#FFFF00"); scene.remove(object); objects.splice(objects.indexOf(object), 1);
                } else showMessage("Wymagany kilof!", "red");
            }
            else if (type === 'string_block') {
                if (equippedTool.type === 'sword') {
                    let amount = getRandomDropAmount();
                    player.string += amount;
                    showMessage(`+${amount} Niƒá`, "white");
                    scene.remove(object);
                    objects.splice(objects.indexOf(object), 1);
                } else {
                    showMessage("Wymagany Miecz!", "red");
                }
            }
            else if (type === 'death_block') {
                const loot = object.userData.loot;
                Object.keys(loot).forEach(k => { 
                    if (player.hasOwnProperty(k)) {
                        if(typeof player[k] === 'number') player[k] += (typeof loot[k] === 'number' ? loot[k] : 0); 
                        else if (k.endsWith('_owned') && loot[k] === true) player[k] = true;
                    }
                });
                showMessage("Odzyskano ekwipunek!", "blue");
                scene.remove(object); objects.splice(objects.indexOf(object), 1);
            }
            else if (type === 'cow' || type === 'zombie' || type === 'spider' || type === 'skeleton' || type === 'sword_skeleton') {
                let dmg = equippedTool.damage;

                if (equippedTool.type !== 'sword' && equippedTool.type !== 'none') {
                    showMessage("Wyposa≈º Miecz!", "red");
                    return;
                }
                
                if (dmg === 1 && type !== 'cow') { showMessage("U≈ºyj miecza!", "red"); return; }
                if (dmg === 1 && type === 'cow') dmg = 1; 

                object.userData.health -= dmg;
                
                const isPoisoned = equippedTool.mat === 'poison';
                if (isPoisoned) { 
                    object.userData.slowEndTime = performance.now() + 3000; 
                    showMessage(`Trafienie (Trucizna)! -${dmg} HP`, "lightgreen"); 
                } else { 
                    showMessage(`Trafienie! -${dmg} HP`, "red"); 
                }

                if (object.userData.health <= 0) killMob(object);
            }
            updateHUD();
        }

        function killMob(object) {
            const type = object.userData.type;
            if (type === 'cow') { player.meat++; player.leather++; showMessage("+1 Miƒôso, +1 Sk√≥ra", "#ffcc00"); }
            else if (type === 'zombie') { player.leather += getRandomDropAmount(); showMessage(`Zabito Zombi!`, "lightgreen"); }
            else if (type === 'spider') { 
                if (player.diamond_sword_owned) { player.venom += 3; showMessage("Zabito PajƒÖka! +3 Jady (Diamentowy Miecz)", "purple"); }
                else { player.venom++; showMessage(`Zabito PajƒÖka! +1 Jad`, "purple"); }
            }
            else if (type === 'skeleton' || type === 'sword_skeleton') { player.arrows += 3; showMessage("Zabito Szkieleta! +3 Strza≈Çy", "white"); }
            scene.remove(object); 
            mobs.splice(mobs.indexOf(object), 1); 
            
            for(let i = activeTraps.length - 1; i >= 0; i--) {
                if (activeTraps[i].mob === object) {
                    scene.remove(activeTraps[i].cage);
                    activeTraps.splice(i, 1);
                }
            }

            updateHUD();
        }

        function onKeyDown(event) {
            if (isGameOver) return; 
            switch (event.code) {
                case 'ArrowUp': case 'KeyW': moveForward = true; break;
                case 'ArrowLeft': case 'KeyA': moveLeft = true; break;
                case 'ArrowDown': case 'KeyS': moveBackward = true; break;
                case 'ArrowRight': case 'KeyD': moveRight = true; break;
                case 'Space': if (canJump) { velocity.y += JUMP_VELOCITY; canJump = false; } break;
                case 'KeyE': if (isInventoryOpen) toggleInventory(); toggleCrafting(); break;
                case 'KeyI': if (isCraftingOpen) toggleCrafting(); toggleInventory(); break;
                case 'Escape': if (isCraftingOpen) toggleCrafting(); else if (isInventoryOpen) toggleInventory(); else if (document.pointerLockElement) document.exitPointerLock(); break;
                case 'KeyR': eatMeat(); break;
                case 'KeyH': 
                    if(player.saplings > 0) { 
                        player.saplings--; 
                        const x = camera.position.x; const z = camera.position.z;
                        const trunkHeight = PLAYER_HEIGHT * 1.5;
                        const leavesScale = 1.5;

                        const trunkGeom = new THREE.CylinderGeometry(0.5 * leavesScale, 1.0 * leavesScale, trunkHeight, 8);
                        const trunk = new THREE.Mesh(trunkGeom, new THREE.MeshLambertMaterial({color:0x8B4513}));
                        trunk.position.set(x,trunkHeight/2,z); trunk.userData={type:'wood',originalColor:0x8B4513}; scene.add(trunk); objects.push(trunk);

                        const leavesGeom = new THREE.ConeGeometry(4 * leavesScale, 6 * leavesScale, 16);
                        const leaves = new THREE.Mesh(leavesGeom, new THREE.MeshLambertMaterial({color:0x2E8B22}));
                        leaves.position.set(x, trunkHeight + (2 * leavesScale), z); scene.add(leaves); trunk.userData.leaves=leaves;

                        updateHUD(); showMessage("Zasadzono!", "lightgreen");
                    } else showMessage("Brak sadzonek!", "red");
                    break;
                case 'KeyQ': 
                    if(player.bow_owned && player.equippedTool === 'bow' && player.equippedArrow) {
                        isChargingBowQ = true; bowChargeStartTime = performance.now(); bowChargeContainer.style.display = 'block';
                    } else if (player.equippedTool !== 'bow') showMessage("Wyposa≈º ≈Çuk (I)!", "yellow");
                    else if (!player.equippedArrow) showMessage("Wybierz strza≈Çy (I)!", "yellow");
                    break;
                
                case 'Digit1': 
                    const pickaxeId = getBestTool('pickaxe');
                    if (pickaxeId) equipTool(pickaxeId);
                    else showMessage("Brak Kilofa!", "yellow");
                    break;
                case 'Digit2': 
                    const axeId = getBestTool('axe');
                    if (axeId) equipTool(axeId);
                    else showMessage("Brak Siekiery!", "yellow");
                    break;
                case 'Digit3': 
                    const swordId = getBestTool('sword');
                    if (swordId) equipTool(swordId);
                    else showMessage("Brak Miecza!", "yellow");
                    break;

                case 'KeyF': 
                    if (player.equippedSpell && document.pointerLockElement === document.body) {
                        const time = performance.now();
                        if (time < lastSpellTime + SPELL_COOLDOWN) {
                            const remaining = Math.ceil((lastSpellTime + SPELL_COOLDOWN - time) / 1000);
                            showMessage(`Oczekiwanie na zaklƒôcie (${remaining}s)`, "cyan");
                            return;
                        }

                        let used = false;
                        
                        // Check if the equipped spell resource is available (they are reusable)
                        if (player.equippedSpell === 'repulsion' && player.repulsionScrolls > 0) { 
                            castRepulsionSpell(); used = true;
                        } else if (player.equippedSpell === 'fireAura' && player.fireAuraScrolls > 0) { 
                            castFireAuraSpell(time); used = true;
                        } else if (player.equippedSpell === 'trap' && player.trapScrolls > 0) { 
                            castTrapSpell(); used = true;
                        } else if (player.equippedSpell === 'teleport' && player.teleportScrolls > 0) { 
                            castTeleportSpell(); used = true;
                        } 
                        
                        if (used) {
                            lastSpellTime = time; // Set cooldown
                        } else {
                            showMessage("Brak zwoj√≥w!", "yellow");
                        }
                    }
                    break;
            }
        }

        function onKeyUp(event) {
            if (isGameOver) return; 
            switch (event.code) {
                case 'ArrowUp': case 'KeyW': moveForward = false; break;
                case 'ArrowLeft': case 'KeyA': moveLeft = false; break;
                case 'ArrowDown': case 'KeyS': moveBackward = false; break;
                case 'ArrowRight': case 'KeyD': moveRight = false; break;
                case 'KeyQ': if (isChargingBowQ) { fireArrow(); isChargingBowQ = false; bowChargeContainer.style.display = 'none'; } break;
            }
        }

        function onMouseDown(event) {
            if (isGameOver || document.pointerLockElement !== document.body) return;
            
            if (event.button === 0) { // LPM - Atak/Wydobycie
                raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
                const intersects = raycaster.intersectObjects(objects.concat(mobs), true);
                
                if (intersects.length > 0 && intersects[0].distance < 12) {
                    let target = intersects[0].object;
                    while(target.parent && target.parent.type !== 'Scene' && !target.userData.type) {
                        target = target.parent;
                    }
                    if(target.userData.type) handleHit(target);
                    else if (target.parent && target.parent.userData.type) handleHit(target.parent);
                }
            } else if (event.button === 2) { // PPM - Budowanie
                if(player.equippedPlan) {
                    raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
                    const intersects = raycaster.intersectObjects(objects);
                    if (intersects.length > 0 && intersects[0].distance < 20) {
                        const p = intersects[0].point;
                        if(player.equippedPlan === 'house') buildHouse(p.x, p.z);
                        else if(player.equippedPlan === 'fence') buildFence(p.x, p.z);
                    }
                }
            }
        }

        function onMouseUp(event) {}

        function fireArrow() {
            if (!player.bow_owned || player.equippedTool !== 'bow') return; 
            let arrowType = player.equippedArrow || 'regular'; 
            if (arrowType === 'regular' && player.arrows > 0) player.arrows--;
            else if (arrowType === 'explosive' && player.explosiveArrows > 0) player.explosiveArrows--;
            else if (arrowType === 'poison' && player.poisonArrows > 0) player.poisonArrows--;
            else return; 
            
            updateHUD();
            const start = camera.position.clone();
            const dir = new THREE.Vector3();
            camera.getWorldDirection(dir);
            const target = start.clone().add(dir.multiplyScalar(100)); 
            shootProjectile(start, target, false, false);
            
            const proj = projectiles[projectiles.length-1];
            proj.userData.isExplosive = (arrowType === 'explosive');
            proj.userData.isPoison = (arrowType === 'poison');
            proj.userData.type = 'player_projectile';
            proj.material.color.setHex(arrowType === 'explosive' ? 0xFF0000 : (arrowType === 'poison' ? 0x00FF00 : 0xAAAAAA));
        }

        function checkSpawns(time) {
            const hasAnyArmor = player.armor_owned || player.iron_armor_owned;

            if (hasAnyArmor && time - lastMobSpawnTime > 10000 && mobs.length < MAX_MOBS) {
                const r = Math.random();
                if (r < 0.33) createZombie((Math.random()-0.5)*300, (Math.random()-0.5)*300);
                else if (r < 0.66) createSkeleton((Math.random()-0.5)*300, (Math.random()-0.5)*300); // Bow skeleton
                else createSwordSkeleton((Math.random()-0.5)*300, (Math.random()-0.5)*300); // Sword skeleton
                lastMobSpawnTime = time;
            }
            if (time - lastCowSpawnTime > 15000 && mobs.filter(m => m.userData.type === 'cow').length < MAX_COWS) {
                 createCow((Math.random()-0.5)*300, (Math.random()-0.5)*300);
                 lastCowSpawnTime = time;
            }
            if (time - lastSulphurSpawnTime > 20000) {
                 spawnSulphurBlock((Math.random()-0.5)*300, (Math.random()-0.5)*300);
                 lastSulphurSpawnTime = time;
            }
        }

        // --- FUNKCJE CRAFTINGU I HUD ---
        function updateHUD() {
            document.getElementById('health-bar').style.width = player.health + '%';
            document.getElementById('hunger-bar').style.width = player.hunger + '%';
            document.getElementById('health-text').innerText = `≈ªycie: ${Math.ceil(player.health)}%`;
            document.getElementById('hunger-text').innerText = `G≈Ç√≥d: ${Math.ceil(player.hunger)}%`;

            // 2. Aktualizacja ZASOB√ìW (#hud)
            const hud = document.getElementById('hud');
            hud.innerHTML = `
                Drewno: ${player.wood} | Kamie≈Ñ: ${player.stone} | ≈ªelazo: ${player.iron}<br>
                Diamenty: ${player.diamonds} | Wƒôgiel: ${player.coal} | Siarka: ${player.sulphur}<br>
                Nici: ${player.string} | Atrament: ${player.blackInk} | Deski: ${player.planks}<br>
                Sk√≥ra: ${player.leather} | Miƒôso: ${player.meat} | Zwoje: ${player.repulsionScrolls + player.fireAuraScrolls + player.trapScrolls + player.teleportScrolls}<br>
                Strza≈Çy: ${player.arrows} | Wyb.: ${player.explosiveArrows} | Tru.: ${player.poisonArrows}
            `;
            
            // 3. Aktualizacja PRZEDMIOT√ìW (#items-display)
            let itemsHtml = '';
            
            const TOOL_LIST = [
                { id: 'wooden_pickaxe', icon: '‚õèÔ∏è', className: 'item-wood' },
                { id: 'stone_pickaxe', icon: '‚õèÔ∏è', className: 'item-stone' },
                { id: 'iron_pickaxe', icon: '‚õèÔ∏è', className: 'item-iron' },
                { id: 'diamond_pickaxe', icon: '‚õèÔ∏è', className: 'item-diamond' },
                { id: 'diamond_axe', icon: 'ü™ì', className: 'item-diamond' },
                { id: 'wooden_axe', icon: 'ü™ì', className: 'item-wood' }, 
                { id: 'stone_sword', icon: 'üó°Ô∏è', className: 'item-stone' },
                { id: 'iron_sword', icon: 'üó°Ô∏è', className: 'item-iron' },
                { id: 'poison_sword', icon: 'üó°Ô∏è', className: 'item-poison' },
                { id: 'diamond_sword', icon: 'üó°Ô∏è', className: 'item-diamond' },
                { id: 'bow', icon: 'üèπ', className: 'item-bow' },
                { id: 'iron_armor', icon: 'üõ°Ô∏è', className: 'item-armor-iron' },
                { id: 'armor', icon: 'üõ°Ô∏è', className: 'item-armor-base' }, 
            ];
            
            TOOL_LIST.forEach(tool => {
                const ownedKey = tool.id + '_owned';
                if (player[ownedKey]) {
                    const equippedClass = player.equippedTool === tool.id ? ' item-equipped' : '';
                    itemsHtml += `<div class="item-icon ${tool.className}${equippedClass}">${tool.icon}</div>`;
                }
            });
            
            itemsDisplay.innerHTML = itemsHtml;
            
            currentToolDisplay.innerText = player.equippedTool ? TOOL_DATA[player.equippedTool].name : 'Brak';

            updateCraftingButtons();
        }


        function updateCraftingButtons() {
           const btn = (id, enable) => document.getElementById(id).disabled = !enable;

           // --- Narzƒôdzia/Bronie/Zbroje, kt√≥re powinny byƒá jednorazowe ---
           
           // Kilofy (Logic simplified for brevity, relying on lowerTier removal)
           const btnWoodPick = document.getElementById('btn-wood-pick');
           btnWoodPick.disabled = toolOwned('wooden_pickaxe') || toolOwned('stone_pickaxe') || toolOwned('iron_pickaxe') || toolOwned('diamond_pickaxe') || player.wood < 3;
           const btnStonePick = document.getElementById('btn-stone-pick');
           btnStonePick.disabled = toolOwned('stone_pickaxe') || toolOwned('iron_pickaxe') || toolOwned('diamond_pickaxe') || player.wood < 2 || player.stone < 1;
           const btnIronPick = document.getElementById('btn-iron-pick');
           btnIronPick.disabled = toolOwned('iron_pickaxe') || toolOwned('diamond_pickaxe') || player.wood < 2 || player.iron < 1;
           const btnDiamondPick = document.getElementById('btn-diamond-pick');
           btnDiamondPick.disabled = toolOwned('diamond_pickaxe') || player.wood < 2 || player.diamonds < 3;
           
           // Siekiera
           const btnDiamondAxe = document.getElementById('btn-diamond-axe');
           btnDiamondAxe.disabled = toolOwned('diamond_axe') || player.wood < 2 || player.diamonds < 3;

           // Miecze
           const btnStoneSword = document.getElementById('btn-stone-sword');
           btnStoneSword.disabled = toolOwned('stone_sword') || toolOwned('iron_sword') || toolOwned('poison_sword') || toolOwned('diamond_sword') || player.stone < 2 || player.wood < 1;
           const btnIronSword = document.getElementById('btn-iron-sword');
           btnIronSword.disabled = toolOwned('iron_sword') || toolOwned('poison_sword') || toolOwned('diamond_sword') || player.iron < 2 || player.wood < 1;
           const btnPoisonSword = document.getElementById('btn-poison-sword');
           btnPoisonSword.disabled = toolOwned('poison_sword') || toolOwned('diamond_sword') || !toolOwned('iron_sword') || player.venom < 1;
           const btnDiamondSword = document.getElementById('btn-diamond-sword');
           btnDiamondSword.disabled = toolOwned('diamond_sword') || player.wood < 1 || player.diamonds < 2;

           // ≈Åuk
           const btnBow = document.getElementById('btn-bow');
           btnBow.disabled = toolOwned('bow') || player.string < 3 || player.wood < 3;

           // Zbroja
           const btnArmor = document.getElementById('btn-armor');
           btnArmor.disabled = toolOwned('armor') || toolOwned('iron_armor') || player.leather < 10;
           const btnIronArmor = document.getElementById('btn-iron-armor');
           btnIronArmor.disabled = toolOwned('iron_armor') || player.iron < 10;
           
           // ZWOJE (crafting tylko raz)
           btn('btn-black-ink', !player.blackInk && player.coal >= 2 && player.diamonds >= 2);
           // Wa≈ºna zmiana: Sprawdzamy, czy gracz posiada zwoje (value > 0), aby ograniczyƒá tworzenie do jednego razu, zgodnie z pro≈õbƒÖ.
           btn('btn-repulsion-scroll', player.repulsionScrolls < 1 && player.diamonds >= 4 && player.string >= 10);
           btn('btn-fire-aura-scroll', player.fireAuraScrolls < 1 && player.blackInk >= 1 && player.string >= 10);
           btn('btn-trap-scroll', player.trapScrolls < 1 && player.iron >= 5 && player.string >= 10); 
           btn('btn-teleport-scroll', player.teleportScrolls < 1 && player.diamonds >= 3 && player.coal >= 2); 


           // --- Powtarzalny Crafting ---
           btn('btn-planks', player.wood >= 1);
           btn('btn-house-plans', player.wood >= 20 && player.stone >= 20);
           btn('btn-fence-plans', player.planks >= 12);
           btn('btn-arrows', player.stone >= 1 && player.wood >= 1);
           btn('btn-explosive-arrows', player.arrows >= 1 && player.sulphur >= 1);
           btn('btn-poison-arrow', player.explosiveArrows >= 1 && player.venom >= 1);
        }
        
        // Funkcja pomocnicza do usuwania starszych, ni≈ºszych przedmiot√≥w
        function removeLowerTier(type, currentTier) {
            const tiers = {
                'pickaxe': ['wooden_pickaxe', 'stone_pickaxe', 'iron_pickaxe', 'diamond_pickaxe'],
                'axe': ['wooden_axe', 'diamond_axe'], 
                'sword': ['stone_sword', 'iron_sword', 'poison_sword', 'diamond_sword'],
            };
            
            if (!tiers[type]) return;

            const currentIndex = tiers[type].indexOf(currentTier);
            if (currentIndex === -1) return;

            for (let i = 0; i < currentIndex; i++) {
                const lowerId = tiers[type][i];
                const ownedKey = lowerId + '_owned';
                if (player[ownedKey]) {
                    player[ownedKey] = false;
                    if (player.equippedTool === lowerId) {
                        player.equippedTool = currentTier;
                    }
                    showMessage(`Usuniƒôto: ${TOOL_DATA[lowerId].name}`, "yellow");
                }
            }
        }

        function craftPlanks() { if(player.wood >= 1) { player.wood--; player.planks += 4; updateHUD(); showMessage("+4 Deski", "lime"); } }
        function craftHousePlans() { if(player.wood >= 20 && player.stone >= 20) { player.wood-=20; player.stone-=20; player.housePlans++; updateHUD(); showMessage("+Plan Domu", "gold"); } }
        function craftFencePlans() { if(player.planks >= 12) { player.planks-=12; player.fencePlans++; updateHUD(); showMessage("+Schemat P≈Çotu", "brown"); } }
        
        // NOWE FUNKCJE CRAFTINGU Z OGRANICZENIEM
        function craftBlackInk() {
            if (!player.blackInk && player.coal >= 2 && player.diamonds >= 2) {
                player.coal -= 2; player.diamonds -= 2; 
                player.blackInk++;
                updateHUD(); showMessage("Stworzono Czarny Atrament!", "black");
            } else { showMessage("Brak surowc√≥w lub ju≈º stworzono!", "red"); }
        }

        function craftRepulsionScroll() {
            if (player.repulsionScrolls < 1 && player.diamonds >= 4 && player.string >= 10) {
                player.diamonds -= 4; player.string -= 10; 
                player.repulsionScrolls++;
                updateHUD(); showMessage("Stworzono Zw√≥j Odpychania!", "purple");
            } else { showMessage("Brak surowc√≥w lub ju≈º stworzono!", "red"); }
        }

        function craftFireAuraScroll() {
            if (player.fireAuraScrolls < 1 && player.blackInk >= 1 && player.string >= 10) {
                player.blackInk--; player.string -= 10; 
                player.fireAuraScrolls++;
                updateHUD(); showMessage("Stworzono Zw√≥j Ognistej Aury!", "orange");
            } else { showMessage("Brak surowc√≥w lub ju≈º stworzono!", "red"); }
        }
        
        function craftTrapScroll() { 
            if (player.trapScrolls < 1 && player.iron >= 5 && player.string >= 10) {
                player.iron -= 5; player.string -= 10; 
                player.trapScrolls++;
                updateHUD(); showMessage("Stworzono Zw√≥j Pu≈Çapki!", "brown");
            } else { showMessage("Brak surowc√≥w lub ju≈º stworzono!", "red"); }
        }
        
        function craftTeleportScroll() { 
            if (player.teleportScrolls < 1 && player.diamonds >= 3 && player.coal >= 2) {
                player.diamonds -= 3; player.coal -= 2; 
                player.teleportScrolls++;
                updateHUD(); showMessage("Stworzono Zw√≥j Teleportacji!", "indigo");
            } else { showMessage("Brak surowc√≥w lub ju≈º stworzono!", "red"); }
        }

        // --- FUNKCJE CRAFTINGU NARZƒòDZI/BRONI/ZBROI ---

        function craftTool(toolId) {
            let costWood = 0, costStone = 0, costIron = 0, costDiam = 0;
            const data = TOOL_DATA[toolId];
            const mat = data.mat;
            const type = data.type;
            
            if(type === 'pickaxe') {
                if(mat==='wood') costWood=3;
                if(mat==='stone') { costWood=2; costStone=1; }
                if(mat==='iron') { costWood=2; costIron=1; }
                if(mat==='diamond') { costWood=2; costDiam=3; }
            } else if(type === 'sword') {
                if(mat==='stone') { costWood=1; costStone=2; }
                if(mat==='iron') { costWood=1; costIron=2; }
                if(mat==='diamond') { costWood=1; costDiam=2; }
            } else if(type === 'axe' && toolId === 'diamond_axe') { 
                 costWood=2; costDiam=3;
            }

            const ownedKey = toolId + '_owned';

            if(!player[ownedKey] && player.wood>=costWood && player.stone>=costStone && player.iron>=costIron && player.diamonds>=costDiam) {
                player.wood-=costWood; player.stone-=costStone; player.iron-=costIron; player.diamonds-=costDiam;
                
                removeLowerTier(type, toolId);
                
                player[ownedKey] = true;
                player.equippedTool = toolId; 
                updateHUD(); 
                showMessage(`Stworzono i Wyposa≈ºono: ${data.name}`, "lime");
            }
        }
        
        function craftArmor(armorId) {
            let costLeather = 0, costIron = 0;
            const ownedKey = armorId + '_owned';
            
            if (armorId === 'armor') costLeather = 10;
            if (armorId === 'iron_armor') costIron = 10;

            if(!player[ownedKey] && player.leather>=costLeather && player.iron>=costIron) {
                player.leather-=costLeather; player.iron-=costIron;
                
                if(armorId === 'iron_armor' && player.armor_owned) {
                    player.armor_owned = false;
                    showMessage(`Usuniƒôto: ${TOOL_DATA['armor'].name}`, "yellow");
                }

                player[ownedKey] = true;
                updateHUD(); 
                showMessage(`Stworzono: ${TOOL_DATA[armorId].name}`, "blue");
            }
        }

        function craftPoisonSword() { 
            const toolId = 'poison_sword';
            const ownedKey = toolId + '_owned';
            const data = TOOL_DATA[toolId];

            if (!player[ownedKey] && player.iron_sword_owned && player.venom>=1) { 
                player.venom--; 
                
                removeLowerTier('sword', toolId);
                
                player[ownedKey]=true; 
                player.equippedTool = toolId;
                updateHUD(); 
                showMessage(`Stworzono i Wyposa≈ºono ${data.name}!`, "green"); 
            }
        }

        function craftBow() { 
            const toolId = 'bow';
            const ownedKey = toolId + '_owned';
            const data = TOOL_DATA[toolId];

            if (!player[ownedKey] && player.string>=3 && player.wood>=3) { 
                player.string-=3; player.wood-=3; 
                player[ownedKey]=true; 
                player.equippedTool = toolId; 
                updateHUD(); 
                showMessage(`Stworzono i Wyposa≈ºono ${data.name}!`, "orange"); 
            } 
        }

        function craftArrows() { if(player.stone>=1 && player.wood>=1) { player.stone--; player.wood--; player.arrows+=5; updateHUD(); showMessage("+5 Strza≈Ç", "white"); } }
        function craftExplosiveArrows() { if(player.arrows>=1 && player.sulphur>=1) { player.arrows--; player.sulphur--; player.explosiveArrows+=5; updateHUD(); showMessage("+5 Wybuchowych Strza≈Ç", "red"); } }
        function craftPoisonArrow() { if(player.explosiveArrows>=1 && player.venom>=1) { player.explosiveArrows--; player.venom--; player.poisonArrows++; updateHUD(); showMessage("+1 TrujƒÖca Strza≈Ça", "green"); } }

        // --- FUNKCJE WYPOSA≈ªANIA (TOOLS, PLANS, ARROWS, SPELLS) ---
        
        function equipTool(toolId) {
            player.equippedTool = toolId;
            updateHUD();
            updateInventoryDisplay();
            showMessage(`Wyposa≈ºono: ${TOOL_DATA[toolId].name}`, "lime");
        }

        function equipPlan(planType) {
            player.equippedPlan = planType;
            updateHUD();
            updateInventoryDisplay();
            showMessage(`Wyposa≈ºono plan: ${planType === 'house' ? 'Dom' : 'P≈Çot'}`, "lightblue");
        }
        
        function equipArrow(arrowType) {
            player.equippedArrow = arrowType;
            updateHUD();
            updateInventoryDisplay();
            showMessage(`Wyposa≈ºono strza≈Çy: ${arrowType}`, "white");
        }
        
        function equipSpell(spellId) {
            player.equippedSpell = spellId;
            updateHUD();
            updateInventoryDisplay();
            let spellName = '';
            if (spellId === 'repulsion') spellName = 'Odpychania';
            else if (spellId === 'fireAura') spellName = 'Ognistej Aury';
            else if (spellId === 'trap') spellName = 'Pu≈Çapki'; 
            else if (spellId === 'teleport') spellName = 'Teleportacji'; 
            showMessage(`Wyposa≈ºono zaklƒôcie: ${spellName}`, "violet");
        }
        
        function equipNone() {
            player.equippedTool = null;
            updateHUD();
            updateInventoryDisplay();
            showMessage("Nie wyposa≈ºono ≈ºadnego narzƒôdzia/broni", "gray");
        }
        
        // --- NOWA FUNKCJA: AKTUALIZACJA WIDOKU EKWIPUNKU ---
        function updateInventoryDisplay() {
            const list = document.getElementById('inventory-list');
            let html = '';

            // 1. NARZƒòDZIA / BRO≈É
            html += '<div class="inventory-section"><h3>Narzƒôdzia i Bronie</h3>';
            
            const toolWeaponList = [
                'wooden_axe', 'diamond_axe',
                'wooden_pickaxe', 'stone_pickaxe', 'iron_pickaxe', 'diamond_pickaxe',
                'stone_sword', 'iron_sword', 'poison_sword', 'diamond_sword',
                'bow',
            ];
            
            toolWeaponList.forEach(id => {
                if (player[id + '_owned']) {
                    const data = TOOL_DATA[id];
                    const isEquipped = player.equippedTool === id;
                    const status = isEquipped ? '<span class="equipped-status"> (WYPOSA≈ªONE)</span>' : '';
                    const buttonText = isEquipped ? 'Ode≈õlij' : 'Wyposa≈º';
                    const buttonAction = isEquipped ? `equipNone()` : `equipTool('${id}')`;
                    
                    html += `
                        <div class="inventory-item">
                            <div class="item-info">
                                ${data.name}${status}
                            </div>
                            <button class="equip-btn" onclick="${buttonAction}">${buttonText}</button>
                        </div>
                    `;
                }
            });

            // Dodanie opcji 'Brak'
            const isNoneEquipped = !player.equippedTool || player.equippedTool === 'bare_hands';
            html += `
                <div class="inventory-item">
                    <div class="item-info">
                        Go≈Çe Rƒôce/Brak Narzƒôdzia ${isNoneEquipped ? '<span class="equipped-status"> (WYPOSA≈ªONE)</span>' : ''}
                    </div>
                    <button class="equip-btn" onclick="equipNone()">Wyposa≈º</button>
                </div>
            `;
            html += '</div>'; // Koniec sekcji narzƒôdzi

            // 2. SCHEMATY/PLANY
            html += '<div class="inventory-section"><h3>Schematy Budowy</h3>';
            const planNames = { 'house': 'Plan Domu (üè†)', 'fence': 'Schemat P≈Çotu (üß±)' };
            
            ['house', 'fence'].forEach(id => {
                if (player[id + 'Plans'] > 0) {
                    const isEquipped = player.equippedPlan === id;
                    const status = isEquipped ? '<span class="equipped-status"> (AKTYWNE)</span>' : '';
                    const buttonText = isEquipped ? 'Anuluj' : 'Wybierz Plan';
                    const buttonAction = isEquipped ? `equipPlan(null)` : `equipPlan('${id}')`;
                    
                    html += `
                        <div class="inventory-item">
                            <div class="item-info">
                                ${planNames[id]} (Posiadane: ${player[id + 'Plans']})${status}
                            </div>
                            <button class="equip-btn" onclick="${buttonAction}">${buttonText}</button>
                        </div>
                    `;
                }
            });
            html += '</div>'; // Koniec sekcji plan√≥w

            // 3. STRZA≈ÅY
            html += '<div class="inventory-section"><h3>Typy Strza≈Ç (Wymagany ≈Åuk)</h3>';
            const arrowTypes = [
                { id: 'regular', name: 'Zwyk≈Çe Strza≈Çy (üèπ)', countKey: 'arrows' },
                { id: 'explosive', name: 'Wybuchowe Strza≈Çy (üí•)', countKey: 'explosiveArrows' },
                { id: 'poison', name: 'TrujƒÖce Strza≈Çy (ü§¢)', countKey: 'poisonArrows' }
            ];

            arrowTypes.forEach(arrow => {
                const count = player[arrow.countKey];
                const isEquipped = player.equippedArrow === arrow.id;
                const status = isEquipped ? '<span class="equipped-status"> (AKTYWNE)</span>' : '';
                const buttonText = isEquipped ? 'Anuluj' : 'Wybierz Strza≈Çy';
                const buttonAction = isEquipped ? `equipArrow(null)` : `equipArrow('${arrow.id}')`;
                
                html += `
                    <div class="inventory-item">
                        <div class="item-info">
                            ${arrow.name} (Posiadane: ${count})${status}
                        </div>
                        <button class="equip-btn" onclick="${buttonAction}" ${count === 0 && !isEquipped ? 'disabled' : ''}>${buttonText}</button>
                    </div>
                `;
            });
            html += '</div>'; // Koniec sekcji strza≈Ç

            // 4. ZAKLƒòCIA/ZWOJE
            html += '<div class="inventory-section"><h3>Zaklƒôcia (U≈ºyj klawisza F)</h3>';
            const spellList = [
                { id: 'repulsion', name: 'Zw√≥j Odpychania (üü£)', countKey: 'repulsionScrolls' },
                { id: 'fireAura', name: 'Zw√≥j Ognistej Aury (üî•)', countKey: 'fireAuraScrolls' },
                { id: 'trap', name: 'Zw√≥j Pu≈Çapki (‚õìÔ∏è)', countKey: 'trapScrolls' },
                { id: 'teleport', name: 'Zw√≥j Teleportacji (üåå)', countKey: 'teleportScrolls' }
            ];

            spellList.forEach(spell => {
                const count = player[spell.countKey];
                const isEquipped = player.equippedSpell === spell.id;
                const status = isEquipped ? '<span class="equipped-status"> (AKTYWNE)</span>' : '';
                const buttonText = isEquipped ? 'Anuluj' : 'Wybierz Zaklƒôcie';
                const buttonAction = isEquipped ? `equipSpell(null)` : `equipSpell('${spell.id}')`;
                
                if (count > 0) {
                    html += `
                        <div class="inventory-item">
                            <div class="item-info">
                                ${spell.name}${status}
                            </div>
                            <button class="equip-btn" onclick="${buttonAction}">${buttonText}</button>
                        </div>
                    `;
                }
            });
            html += '</div>'; // Koniec sekcji zwoj√≥w

            list.innerHTML = html;
        }


        // --- FUNKCJE BUDOWANIA ---

        function buildHouse(x, z) {
            if (player.housePlans <= 0 || player.equippedPlan !== 'house') {
                showMessage("Brak planu domu!", "red");
                return;
            }
            player.housePlans--;
            
            const floorX = Math.floor(x / 20) * 20;
            const floorZ = Math.floor(z / 20) * 20;

            const HOUSE_SIZE = 18;
            const HOUSE_HEIGHT = 15;
            const center = new THREE.Vector3(floorX, 0, floorZ);

            const safeZone = new THREE.Box3(
                new THREE.Vector3(center.x - HOUSE_SIZE / 2 - 5, -1, center.z - HOUSE_SIZE / 2 - 5),
                new THREE.Vector3(center.x + HOUSE_SIZE / 2 + 5, 100, center.z + HOUSE_SIZE / 2 + 5)
            );
            safeZones.push(safeZone);
            
            const wallMat = new THREE.MeshLambertMaterial({ color: 0xA0522D }); 
            const roofMat = new THREE.MeshLambertMaterial({ color: 0x8B0000 }); 

            const floor = new THREE.Mesh(new THREE.BoxGeometry(HOUSE_SIZE, 0.5, HOUSE_SIZE), wallMat);
            floor.position.set(center.x, 0.25, center.z);
            scene.add(floor);
            objects.push(floor);

            const wallGeom = new THREE.BoxGeometry(HOUSE_SIZE, HOUSE_HEIGHT, 0.5);
            const wallPositions = [
                {x: center.x, z: center.z - HOUSE_SIZE/2 + 0.25, rot: 0},
                {x: center.x, z: center.z + HOUSE_SIZE/2 - 0.25, rot: 0},
                {x: center.x - HOUSE_SIZE/2 + 0.25, z: center.z, rot: Math.PI/2},
                {x: center.x + HOUSE_SIZE/2 - 0.25, z: center.z, rot: Math.PI/2}
            ];

            wallPositions.forEach(pos => {
                const wall = new THREE.Mesh(wallGeom, wallMat);
                wall.position.set(pos.x, HOUSE_HEIGHT / 2 + 0.5, pos.z);
                wall.rotation.y = pos.rot;
                scene.add(wall);
                objects.push(wall);
            });

            const roof = new THREE.Mesh(new THREE.ConeGeometry(HOUSE_SIZE * 0.7, HOUSE_SIZE * 0.5, 4), roofMat);
            roof.rotation.y = Math.PI / 4;
            roof.position.set(center.x, HOUSE_HEIGHT + (HOUSE_SIZE * 0.25) + 0.5, center.z);
            scene.add(roof);

            showMessage("Zbudowano Dom! (Strefa Bezpiecze≈Ñstwa)", "gold");
            player.equippedPlan = null;
            updateHUD();
        }
        
        function buildFence(x, z) {
            if (player.fencePlans <= 0 || player.equippedPlan !== 'fence') {
                showMessage("Brak schematu p≈Çotu!", "red");
                return;
            }
            player.fencePlans--;
            
            const positionX = Math.floor(x / 5) * 5;
            const positionZ = Math.floor(z / 5) * 5;
            const FENCE_HEIGHT = 4;
            const FENCE_WIDTH = 0.5;
            const FENCE_LENGTH = 5;

            const postMat = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
            const postGeom = new THREE.BoxGeometry(FENCE_WIDTH, FENCE_HEIGHT, FENCE_WIDTH);
            const post = new THREE.Mesh(postGeom, postMat);
            post.position.set(positionX, FENCE_HEIGHT / 2 + 0.25, positionZ);
            scene.add(post);
            objects.push(post);

            const crossbarGeom = new THREE.BoxGeometry(FENCE_WIDTH, FENCE_WIDTH, FENCE_LENGTH - FENCE_WIDTH);
            crossbarGeom.rotateY(Math.PI / 2); 
            const crossbarMat = new THREE.MeshLambertMaterial({ color: 0x694200 });

            const crossbar1 = new THREE.Mesh(crossbarGeom, crossbarMat);
            crossbar1.position.set(positionX, FENCE_HEIGHT * 0.3 + 0.25, positionZ);
            scene.add(crossbar1);
            objects.push(crossbar1);

            const crossbar2 = new THREE.Mesh(crossbarGeom, crossbarMat);
            crossbar2.position.set(positionX, FENCE_HEIGHT * 0.7 + 0.25, positionZ);
            scene.add(crossbar2);
            objects.push(crossbar2);

            showMessage("Zbudowano element P≈Çotu!", "brown");
            player.equippedPlan = null;
            updateHUD();
        }

        // --- FUNKCJE ZAKLƒòƒÜ ---
        function castRepulsionSpell() {
            updateHUD();
            showMessage("U≈ºyto Odpychania!", "purple");
            
            const playerPos = camera.position.clone();
            
            mobs.forEach(mob => {
                const dist = mob.position.distanceTo(playerPos);
                if (dist > 1 && dist < REPULSION_CAST_RANGE) {
                    const pushDir = mob.position.clone().sub(playerPos).normalize();
                    mob.userData.velocity = pushDir.multiplyScalar(REPULSION_PUSH_FORCE); 
                }
            });
        }

        function castFireAuraSpell(time) {
            if (isFireAuraActive) {
                showMessage("Aura ju≈º aktywna!", "red");
                return;
            }
            isFireAuraActive = true;
            lastAuraDamageTime = time;
            fireAuraEndTime = time + FIRE_AURA_DURATION;
            
            let auraMesh = scene.getObjectByName('fireAura');
            if (!auraMesh) {
                const geo = new THREE.SphereGeometry(FIRE_AURA_RANGE, 32, 32); 
                const mat = new THREE.MeshBasicMaterial({ color: 0xFF4500, transparent: true, opacity: 0.2, side: THREE.DoubleSide });
                auraMesh = new THREE.Mesh(geo, mat);
                auraMesh.name = 'fireAura';
                auraMesh.position.y = PLAYER_HEIGHT / 2;
                scene.add(auraMesh);
            }
            auraMesh.visible = true;
            
            updateHUD();
            showMessage("U≈ºyto Ognistej Aury! (20s)", "orange");
        }
        
        function castTrapSpell() { 
            if (activeTraps.length > 0) {
                showMessage("Pu≈Çapka ju≈º aktywna!", "red");
                return;
            }
            
            const playerPos = camera.position.clone();
            let nearestZombie = null;
            let minDistSq = Infinity;

            mobs.forEach(mob => {
                if (mob.userData.type === 'zombie' && !mob.userData.isTrapped) {
                    const distSq = mob.position.distanceToSquared(playerPos);
                    if (distSq < minDistSq) {
                        minDistSq = distSq;
                        nearestZombie = mob;
                    }
                }
            });

            if (nearestZombie && minDistSq < REPULSION_CAST_RANGE * REPULSION_CAST_RANGE) { 
                updateHUD();
                showMessage("Zombi Z≈Çapany!", "brown");

                const mobPos = nearestZombie.position.clone();

                const cageGroup = new THREE.Group();
                const barMat = new THREE.MeshBasicMaterial({ color: 0x666666 });
                const boxSize = 3; 
                
                const barGeo = new THREE.BoxGeometry(0.1, 8, 0.1);
                const bars = [
                    new THREE.Mesh(barGeo, barMat), new THREE.Mesh(barGeo, barMat),
                    new THREE.Mesh(barGeo, barMat), new THREE.Mesh(barGeo, barMat)
                ];
                
                bars[0].position.set(boxSize/2, 4, boxSize/2);
                bars[1].position.set(-boxSize/2, 4, boxSize/2);
                bars[2].position.set(boxSize/2, 4, -boxSize/2);
                bars[3].position.set(-boxSize/2, 4, -boxSize/2);

                bars.forEach(bar => cageGroup.add(bar));

                cageGroup.position.copy(mobPos);
                scene.add(cageGroup);

                nearestZombie.userData.isTrapped = true;
                
                activeTraps.push({ 
                    mob: nearestZombie, 
                    cage: cageGroup, 
                    endTime: performance.now() + TRAP_DURATION 
                });

            } else {
                showMessage("Nie znaleziono Zombi w zasiƒôgu!", "yellow");
            }
        }
        
        function castTeleportSpell() { 
            updateHUD();
            showMessage("Teleportacja 100 blok√≥w do przodu!", "indigo");
            
            const distance = 100; 
            const dir = new THREE.Vector3();
            camera.getWorldDirection(dir);
            dir.y = 0; 
            dir.normalize();

            const newX = camera.position.x + dir.x * distance;
            const newZ = camera.position.z + dir.z * distance;
            
            const mapLimit = 950;
            const clampedX = Math.max(-mapLimit, Math.min(mapLimit, newX));
            const clampedZ = Math.max(-mapLimit, Math.min(mapLimit, newZ));

            camera.position.set(clampedX, PLAYER_HEIGHT, clampedZ);
            velocity.set(0, 0, 0); 
        }

        // --- FUNKCJE POCISK√ìW I KONIEC GRY ---

        function handleGameOver() {
            isGameOver = true;
            document.exitPointerLock();
            // Zapis ekwipunku gracza jako ≈Çup
            const loot = {};
            Object.keys(player).forEach(key => {
                if (key !== 'health' && key !== 'hunger' && key !== 'equippedTool' && key !== 'equippedPlan' && key !== 'equippedArrow' && key !== 'equippedSpell') {
                    loot[key] = player[key];
                }
            });
            // Reset tymczasowych zmiennych
            loot.repulsionScrolls = 0;
            loot.fireAuraScrolls = 0;
            loot.trapScrolls = 0;
            loot.teleportScrolls = 0;
            loot.blackInk = 0;

            createDeathBlock(camera.position.x, camera.position.z, loot);
            
            blockerTitle.innerText = "GAME OVER!";
            blockerMessage.innerHTML = "Zmar≈Çe≈õ z g≈Çodu lub w walce!<br>Znajd≈∫ niebieski blok na mapie, by odzyskaƒá ekwipunek.<br>Kliknij, by zaczƒÖƒá od nowa.";
            blocker.style.display = 'flex';
        }
        
        function shootProjectile(startPos, targetPos, isWeb, isEnemy) {
            const geo = new THREE.SphereGeometry(0.5, 8, 8);
            const mat = new THREE.MeshLambertMaterial({ color: isWeb ? 0xFFFFFF : (isEnemy ? 0xDDDDDD : 0xAAAAAA) });
            const projectile = new THREE.Mesh(geo, mat);
            projectile.position.copy(startPos);

            const velocityVector = targetPos.clone().sub(startPos).normalize();
            
            // Dodanie niewielkiej losowo≈õci dla celno≈õci wroga
            if (isEnemy) {
                velocityVector.x += (Math.random() - 0.5) * 0.1;
                velocityVector.y += (Math.random() - 0.5) * 0.1;
                velocityVector.z += (Math.random() - 0.5) * 0.1;
                velocityVector.normalize();
            }
            
            const speed = isWeb ? 150 : 400; // Pajƒôczyna jest wolniejsza

            projectile.userData = {
                velocity: velocityVector.multiplyScalar(speed),
                isWeb: isWeb,
                isEnemy: isEnemy,
                damage: isWeb ? 0 : (isEnemy ? SKELETON_BOW_DAMAGE : REGULAR_ARROW_DAMAGE),
                maxRangeSq: ARROW_MAX_RANGE * ARROW_MAX_RANGE,
                startPos: startPos.clone(),
                isExplosive: false,
                isPoison: false,
            };
            
            scene.add(projectile);
            projectiles.push(projectile);
        }

        function updateProjectiles(delta) {
            const playerBox = new THREE.Box3().setFromCenterAndSize(camera.position, new THREE.Vector3(2, PLAYER_HEIGHT, 2));

            for (let i = projectiles.length - 1; i >= 0; i--) {
                const proj = projectiles[i];
                const data = proj.userData;
                
                // Zastosowanie ruchu
                proj.position.x += data.velocity.x * delta;
                proj.position.y += data.velocity.y * delta;
                proj.position.z += data.velocity.z * delta;

                // Prosta grawitacja dla pocisk√≥w gracza (strza≈Çy)
                if (!data.isWeb && !data.isEnemy) { 
                    data.velocity.y -= 9.8 * 100 * delta; 
                }

                let hit = false;
                
                // 1. Sprawdzenie kolizji z Graczem (tylko pociski wroga)
                if (data.isEnemy) {
                    const projBox = new THREE.Box3().setFromObject(proj);
                    if (playerBox.intersectsBox(projBox)) {
                        
                        let damage = data.damage;
                        if(player.iron_armor_owned) damage *= 0.5;
                        else if (player.armor_owned) damage *= 0.75;
                        
                        if (data.isWeb) { // Pajƒôczyna PajƒÖka
                            slowEndTime = performance.now() + 5000;
                            slowOverlay.style.display = 'block';
                            showMessage("Spowolnienie (Pajƒôczyna)!", "lightgreen");
                            
                        } else { // Zwyk≈Çy pocisk wroga (np. strza≈Ça szkieleta)
                            player.health -= damage;
                            showMessage("Trafienie! -" + damage.toFixed(1) + " HP", "red");
                        }

                        if(player.health <= 0) handleGameOver();
                        updateHUD();
                        hit = true;
                    }
                }
                
                // 2. Sprawdzenie kolizji z Mobami (tylko pociski gracza)
                if (!data.isEnemy) {
                    mobs.forEach(mob => {
                        if (hit) return; // Ju≈º w co≈õ trafiono

                        const mobBox = new THREE.Box3().setFromObject(mob);
                        const projBox = new THREE.Box3().setFromObject(proj);

                        if (mobBox.intersectsBox(projBox)) {
                            mob.userData.health -= data.damage; 
                            
                            if (data.isExplosive) {
                                mob.userData.health -= EXPLOSIVE_ARROW_DAMAGE; 
                                // Wizualizacja (efekt wybuchu jest ju≈º zdefiniowany w HTML)
                                const explosionOverlay = document.getElementById('explosion-overlay');
                                explosionOverlay.style.opacity = 1;
                                explosionOverlay.style.transform = `translate(-50%, -50%) translate3d(${proj.position.x}px, 0px, ${proj.position.z}px) scale(1)`;
                                setTimeout(() => { explosionOverlay.style.opacity = 0; explosionOverlay.style.transform = `translate(-50%, -50%) scale(0)`; }, 100);
                                showMessage("Wybuch!", "red");
                            }
                            
                            if (data.isPoison) { 
                                mob.userData.slowEndTime = performance.now() + 5000;
                                showMessage("Trafienie TruciznƒÖ!", "lightgreen");
                            }
                            
                            if(mob.userData.health <= 0) killMob(mob);
                            
                            updateHUD();
                            hit = true;
                        }
                    });
                }
                
                // 3. Sprawdzenie kolizji ze ≈örodowiskiem
                if (!data.isWeb) { 
                    raycaster.set(proj.position.clone(), data.velocity.clone().normalize());
                    const intersects = raycaster.intersectObjects(objects);

                    if (intersects.length > 0 && intersects[0].distance < 1) { 
                        hit = true;
                    }
                }
                
                // 4. Sprawdzenie maksymalnego zasiƒôgu
                if (proj.position.distanceToSquared(data.startPos) > data.maxRangeSq) {
                    hit = true;
                }

                if (hit) {
                    scene.remove(proj);
                    projectiles.splice(i, 1);
                }
            }
        }


        function animate() {
            requestAnimationFrame(animate);
            const time = performance.now();
            const delta = (time - prevTime) / 1000;
            prevTime = time;

            if (document.pointerLockElement === document.body && !isGameOver) {
                checkSpawns(time);

                // --- 1. Proximity and Spell Cooldown Checks ---
                let isSwordSkeletonNear = false;
                const playerPosClone = camera.position.clone();

                const remainingCooldown = Math.max(0, lastSpellTime + SPELL_COOLDOWN - time);
                if (remainingCooldown > 0) {
                    const seconds = Math.ceil(remainingCooldown / 1000);
                    spellCooldownDisplay.innerText = `${seconds}s`;
                    spellCooldownDisplay.style.display = 'flex';
                } else {
                    spellCooldownDisplay.style.display = 'none';
                }

                if (isChargingBowQ) { 
                    const factor = Math.min(1, (time - bowChargeStartTime)/1000/MAX_CHARGE_TIME);
                    bowChargeBar.style.width = `${factor * 100}%`;
                }

                for (let i = gasClouds.length - 1; i >= 0; i--) {
                    const c = gasClouds[i];
                    if (time - c.creationTime > 10000) { scene.remove(c.mesh); gasClouds.splice(i, 1); continue; }
                    if (Math.floor(time) % 60 === 0) {
                        mobs.forEach(m => {
                            if (m.position.distanceTo(c.mesh.position) < 10) {
                                m.userData.health -= 1;
                                if(m.userData.health <= 0) killMob(m);
                            }
                        });
                    }
                }
                
                for (let i = activeTraps.length - 1; i >= 0; i--) {
                    const trap = activeTraps[i];
                    if (time > trap.endTime) {
                        scene.remove(trap.cage);
                        trap.mob.userData.isTrapped = false;
                        activeTraps.splice(i, 1);
                    } else {
                        trap.mob.userData.isTrapped = true;
                        trap.mob.userData.velocity.set(0, 0, 0); 
                        trap.cage.position.copy(trap.mob.position);
                        trap.cage.position.y = 0; 
                    }
                }
                
                if (isFireAuraActive) {
                    const auraMesh = scene.getObjectByName('fireAura');
                    if (time > fireAuraEndTime) {
                        isFireAuraActive = false;
                        if(auraMesh) auraMesh.visible = false;
                        showMessage("Aura Wygas≈Ça", "orange");
                    } else {
                        if(auraMesh) auraMesh.position.set(camera.position.x, PLAYER_HEIGHT / 2, camera.position.z);

                        if (time - lastAuraDamageTime >= 100) {
                            mobs.forEach(mob => {
                                if (mob.position.distanceToSquared(camera.position) < FIRE_AURA_RANGE_SQ) {
                                    mob.userData.health -= FIRE_AURA_DAMAGE_PER_SEC * (0.1); 
                                    if (mob.userData.health <= 0) killMob(mob);
                                }
                            });
                            lastAuraDamageTime = time;
                        }
                    }
                }


                // --- 2. Hunger and Safe Zone Logic ---
                let inSafeZone = false;
                for(let zone of safeZones) { if(zone.containsPoint(camera.position)) inSafeZone = true; }

                if(inSafeZone) {
                    slowEndTime = 0; slowOverlay.style.display = 'none';
                } else {
                    // Check for Sword Skeleton proximity (for hunger drain)
                    mobs.forEach(mob => {
                        if (mob.userData.type === 'sword_skeleton') {
                            const distSq = mob.position.distanceToSquared(playerPosClone);
                            // 10 kratek to 10 * 10 = 100 w odleg≈Ço≈õci kwadratowej
                            if (distSq < mob.userData.hungerAuraRange * mob.userData.hungerAuraRange) {
                                isSwordSkeletonNear = true;
                            }
                        }
                    });
                    
                    let hungerRate = BASE_HUNGER_DEPLETION_RATE;
                    if (isSwordSkeletonNear) { // 3 times faster
                        hungerRate *= 3;
                    }

                    if(player.hunger > 0) {
                        player.hunger -= hungerRate * delta; if(player.hunger<=0) player.hunger=0;
                        if(Math.floor(time)%2==0) updateHUD();
                    } else {
                        player.health -= 5 * delta; if(player.health<=0) handleGameOver(); updateHUD();
                    }
                }

                updateProjectiles(delta); // WYWO≈ÅANIE POPRAWIONE

                velocity.x -= velocity.x * 10.0 * delta;
                velocity.z -= velocity.z * 10.0 * delta;
                velocity.y -= 9.8 * 100.0 * delta; 
                direction.z = Number(moveForward) - Number(moveBackward);
                direction.x = Number(moveRight) - Number(moveLeft);
                direction.normalize(); 

                let currentSpeed = BASE_SPEED;
                if (player.iron_armor_owned) currentSpeed *= IRON_ARMOR_PENALTY; 
                if (time < slowEndTime) currentSpeed *= WEB_SLOW_FACTOR; else slowOverlay.style.display = 'none';

                if (moveForward || moveBackward) velocity.z -= direction.z * currentSpeed * delta;
                if (moveLeft || moveRight) velocity.x -= direction.x * currentSpeed * delta;

                const fwd = new THREE.Vector3(); camera.getWorldDirection(fwd); fwd.y = 0; fwd.normalize();
                const right = new THREE.Vector3(); right.crossVectors(fwd, new THREE.Vector3(0, 1, 0)).normalize();
                
                camera.position.x -= (right.x * velocity.x + fwd.x * velocity.z) * delta;
                camera.position.z -= (right.z * velocity.x + fwd.z * velocity.z) * delta;
                camera.position.y += velocity.y * delta;

                if (camera.position.y < PLAYER_HEIGHT) { velocity.y = 0; camera.position.y = PLAYER_HEIGHT; canJump = true; }

                // --- 4. Mob Movement/AI/Attacks ---
                mobs.forEach(mob => {
                    const data = mob.userData;
                    
                    if (data.isTrapped) return; 

                    let dx=0, dz=0;
                    let mobSpeed = data.walkSpeed;
                    if (time < data.slowEndTime) mobSpeed *= 0.7; 
                    
                    if(data.velocity && data.velocity.lengthSq() > 0.01) {
                         const pushDelta = data.velocity.clone().multiplyScalar(delta);
                         mob.position.x += pushDelta.x;
                         mob.position.z += pushDelta.z;
                         
                         data.velocity.multiplyScalar(0.9); 
                         return; 
                    }


                    let pushed = false;
                    for (let zone of safeZones) {
                        const center = new THREE.Vector3(); zone.getCenter(center);
                        const size = new THREE.Vector3(); zone.getSize(size);
                        const repelDist = (Math.max(size.x, size.z) / 2) + 10;
                        if (mob.position.distanceTo(center) < repelDist) {
                            const pushDir = mob.position.clone().sub(center).normalize();
                            dx = pushDir.x * mobSpeed * delta; dz = pushDir.z * mobSpeed * delta;
                            pushed = true;
                            if (zone.containsPoint(mob.position)) mob.position.add(pushDir.multiplyScalar(5));
                        }
                    }

                    if (!pushed) {
                         if (data.type === 'cow') {
                            if (time > data.nextTurnTime) {
                                data.walkDirection = data.walkDirection || new THREE.Vector3();
                                data.walkDirection.set(Math.random()-0.5, 0, Math.random()-0.5).normalize();
                                mob.rotation.y = Math.atan2(data.walkDirection.x, data.walkDirection.z);
                                data.nextTurnTime = time + 2000;
                            }
                            dx = data.walkDirection.x * mobSpeed * delta;
                            dz = data.walkDirection.z * mobSpeed * delta;
                            if (data.head) {
                                data.head.rotation.x = Math.sin(time * 2) * 0.1;
                                data.head.rotation.y = Math.cos(time * 3) * 0.1;
                            }
                        } else {
                            const pPos = camera.position.clone();
                            const dist = mob.position.distanceTo(pPos);
                            mob.rotation.y = Math.atan2(pPos.x - mob.position.x, pPos.z - mob.position.z);
                            
                            if (data.type === 'skeleton') {
                                if (dist > SKELETON_RANGE) { const d = pPos.sub(mob.position).normalize(); dx = d.x*mobSpeed*delta; dz = d.z*mobSpeed*delta; }
                                if (dist <= SKELETON_RANGE + 10 && time > data.lastAttackTime + data.attackCooldown) {
                                    const arrowStartPos = mob.position.clone();
                                    arrowStartPos.y = 8; 
                                    
                                    const playerAimPos = camera.position.clone();
                                    playerAimPos.y = camera.position.y; 

                                    shootProjectile(arrowStartPos, playerAimPos, false, true); 
                                    data.lastAttackTime = time;
                                }
                            } else if (data.type === 'spider') {
                                if (dist > 20) { const d = pPos.sub(mob.position).normalize(); dx = d.x*mobSpeed*delta; dz = d.z*mobSpeed*delta; }
                                if (dist <= 30 && time > data.lastAttackTime + data.attackCooldown) {
                                    shootProjectile(mob.position, camera.position, true, false); data.lastAttackTime = time;
                                }
                            } else if (data.type === 'zombie' || data.type === 'sword_skeleton') {
                                if (dist > data.attackRange) { const d = pPos.sub(mob.position).normalize(); dx = d.x*mobSpeed*delta; dz = d.z*mobSpeed*delta; }
                                else if (time > data.lastAttackTime + data.attackCooldown) {
                                    let dmg = data.type === 'sword_skeleton' ? data.damage : ZOMBIE_ATTACK_DAMAGE; // 10 dmg dla sword_skeleton
                                    if(player.iron_armor_owned) dmg *= 0.5;
                                    else if (player.armor_owned) dmg *= 0.75;
                                    player.health -= dmg;
                                    showMessage(data.type === 'sword_skeleton' ? "Ciƒôcie Mieczem!" : "Ugryzienie!", "red"); data.lastAttackTime = time;
                                    if(player.health<=0) handleGameOver();
                                }
                            }
                        }
                    }
                    mob.position.x += dx; mob.position.z += dz;
                });
            }
            renderer.render(scene, camera);
        }
        function onWindowResize() { camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); }
    </script>
</body>
</html>
